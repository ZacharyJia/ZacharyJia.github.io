<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="搞网络的对于 Wireshark 这个抓包工具应该非常熟悉了，在抓包分析的时候非常好用，很大的一个原因就是 Wireshark 内置了大量的协议解析插件，基本上你叫得上来的协议，Wireshark都能给你解析出来。
但是啥事儿都有个万一，特别是像我们这种搞网络协议开发、修改的，经常就会遇到各种奇葩的网络协议，或者是自己拍脑瓜设计出来的网络协议，在调试的时候Wireshark不能正确解析，一个字节一个字节对着查那可真是看得眼都要瞎了。"><title>自己动手编写Wireshark Lua插件解析自定义协议</title><link rel=canonical href=https://blog.zacharyjia.me/p/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99wireshark-lua%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="自己动手编写Wireshark Lua插件解析自定义协议"><meta property="og:description" content="搞网络的对于 Wireshark 这个抓包工具应该非常熟悉了，在抓包分析的时候非常好用，很大的一个原因就是 Wireshark 内置了大量的协议解析插件，基本上你叫得上来的协议，Wireshark都能给你解析出来。
但是啥事儿都有个万一，特别是像我们这种搞网络协议开发、修改的，经常就会遇到各种奇葩的网络协议，或者是自己拍脑瓜设计出来的网络协议，在调试的时候Wireshark不能正确解析，一个字节一个字节对着查那可真是看得眼都要瞎了。"><meta property="og:url" content="https://blog.zacharyjia.me/p/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99wireshark-lua%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/"><meta property="og:site_name" content="Zachary's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="wireshark"><meta property="article:tag" content="网络"><meta property="article:published_time" content="2018-02-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-02-01T00:00:00+00:00"><meta name=twitter:title content="自己动手编写Wireshark Lua插件解析自定义协议"><meta name=twitter:description content="搞网络的对于 Wireshark 这个抓包工具应该非常熟悉了，在抓包分析的时候非常好用，很大的一个原因就是 Wireshark 内置了大量的协议解析插件，基本上你叫得上来的协议，Wireshark都能给你解析出来。
但是啥事儿都有个万一，特别是像我们这种搞网络协议开发、修改的，经常就会遇到各种奇葩的网络协议，或者是自己拍脑瓜设计出来的网络协议，在调试的时候Wireshark不能正确解析，一个字节一个字节对着查那可真是看得眼都要瞎了。"></head><body><div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hub711587dd8549032a5441bfdfb2dc9e8_883541_300x300_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🍥</span></figure><h1 class=site-name><a href=https://blog.zacharyjia.me>Zachary's Blog</a></h1><h2 class=site-description>贾泽群的个人博客</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://blog.zacharyjia.me class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%BC%80%E5%8F%91/>开发</a></header><h2 class=article-title><a href=/p/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E7%BC%96%E5%86%99wireshark-lua%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/>自己动手编写Wireshark Lua插件解析自定义协议</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Feb 01, 2018</time></footer></div></header><section class=article-content><p>搞网络的对于 Wireshark 这个抓包工具应该非常熟悉了，在抓包分析的时候非常好用，很大的一个原因就是 Wireshark 内置了大量的协议解析插件，基本上你叫得上来的协议，Wireshark都能给你解析出来。</p><p>但是啥事儿都有个万一，特别是像我们这种搞网络协议开发、修改的，经常就会遇到各种奇葩的网络协议，或者是自己拍脑瓜设计出来的网络协议，在调试的时候Wireshark不能正确解析，一个字节一个字节对着查那可真是看得眼都要瞎了。</p><p>最近就遇上这么一个协议，其实也算不上协议，就是 Ethernet in UDP的封装：因为某些特殊的原因，需要将某个网口接收到的以太网数据帧，全部打包到UDP当中，作为UDP的PayLoad去解析。比较麻烦的就是，还非要把UDP PayLoad的前两个字节设置成自己的两个特殊字段，从第三个字段开始才是以太网数据帧。</p><p>因为要开发相应的程序，需要反复调试对比，所以肯定就得动用Wireshark去分析，但是Wireshark又默认不支持这样的协议，所以对比起来很麻烦。网上查了一下相关的资料，发现可以用C去写插件，然后编译成链接库给Wireshark用，但是尝试了一会儿之后，发现实在是太麻烦了，编译环境搞了半天都搞不定。遂弃之，研究使用Lua脚本语言进行解析。</p><h1 id=0x01-基础知识>0x01 基础知识</h1><p>Lua是一种轻量级的脚本语言，解释执行，不需要编译器之类的。 Lua的基本语法可以参考 <a class=link href=http://www.lua.org/start.html target=_blank rel=noopener>官网</a> 或者 <a class=link href=http://www.runoob.com/lua/lua-tutorial.html target=_blank rel=noopener>菜鸟教程</a>。
Wireshark内置了对Lua脚本的支持，可以直接编写Lua脚本，无需配置额外的环境，使用起来还是非常方便的。 [Wireshark Developer&rsquo;s Guide]里的第10章和第11章都是关于Lua支持的文档，有需要的话可以详细查阅。</p><p>使用Lua编写Wireshark协议解析插件，有几个比较重要的概念:</p><ol><li>Dissector，中文直译是解剖器，就是用来解析包的类，我们最终要编写的，也是一个Dissector。</li><li>DissectorTable，解析器表是Wireshark中解析器的组织形式，是某一种协议的子解析器的一个列表，其作用是把所有的解析器组织成一种树状结构，便于Wireshark在解析包的时候自动选择对应的解析器。例如TCP协议的子解析器 http, smtp, sip等都被加在了"tcp.port"这个解析器表中，可以根据抓到的包的不同的tcp端口号，自动选择对应的解析器。</li></ol><h1 id=0x02-一个例子>0x02 一个例子</h1><p>我们先来看一下上面说的那个封装格式的脚本例子：（<code>--</code>后面的是注释）</p><div class=highlight><pre class=chroma><code class=language-lua data-lang=lua><span class=kr>do</span>
    <span class=c1>--协议名称为DT，在Packet Details窗格显示为Nselab.Zachary DT</span>
    <span class=kd>local</span> <span class=n>p_DT</span> <span class=o>=</span> <span class=n>Proto</span><span class=p>(</span><span class=s2>&#34;DT&#34;</span><span class=p>,</span><span class=s2>&#34;Nselab.Zachary DT&#34;</span><span class=p>)</span>
    <span class=c1>--协议的各个字段</span>
    <span class=kd>local</span> <span class=n>f_identifier</span> <span class=o>=</span> <span class=n>ProtoField.uint8</span><span class=p>(</span><span class=s2>&#34;DT.identifier&#34;</span><span class=p>,</span><span class=s2>&#34;Identifier&#34;</span><span class=p>,</span> <span class=n>base.HEX</span><span class=p>)</span>
    <span class=c1>--这里的base是显示的时候的进制，详细可参考https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_ProtoField</span>
    <span class=kd>local</span> <span class=n>f_speed</span> <span class=o>=</span> <span class=n>ProtoField.uint8</span><span class=p>(</span><span class=s2>&#34;DT.speed&#34;</span><span class=p>,</span> <span class=s2>&#34;Speed&#34;</span><span class=p>,</span> <span class=n>base.HEX</span><span class=p>)</span>

    <span class=c1>--这里把DT协议的全部字段都加到p_DT这个变量的fields字段里</span>
    <span class=n>p_DT.fields</span> <span class=o>=</span> <span class=p>{</span><span class=n>f_identifier</span><span class=p>,</span> <span class=n>f_speed</span><span class=p>}</span>
    
    <span class=c1>--这里是获取data这个解析器</span>
    <span class=kd>local</span> <span class=n>data_dis</span> <span class=o>=</span> <span class=n>Dissector.get</span><span class=p>(</span><span class=s2>&#34;data&#34;</span><span class=p>)</span>
    
    <span class=kd>local</span> <span class=kr>function</span> <span class=nf>DT_dissector</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>pkt</span><span class=p>,</span><span class=n>root</span><span class=p>)</span>
        <span class=kd>local</span> <span class=n>buf_len</span> <span class=o>=</span> <span class=n>buf</span><span class=p>:</span><span class=n>len</span><span class=p>();</span>
        <span class=c1>--先检查报文长度，太短的不是我的协议</span>
        <span class=kr>if</span> <span class=n>buf_len</span> <span class=o>&lt;</span> <span class=mi>16</span> <span class=kr>then</span> <span class=kr>return</span> <span class=kc>false</span> <span class=kr>end</span>

        <span class=c1>--验证一下identifier这个字段是不是0x12,如果不是的话，认为不是我要解析的packet</span>
        <span class=kd>local</span> <span class=n>v_identifier</span> <span class=o>=</span> <span class=n>buf</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
        <span class=kr>if</span> <span class=p>(</span><span class=n>v_identifier</span><span class=p>:</span><span class=n>uint</span><span class=p>()</span> <span class=o>~=</span> <span class=mh>0x12</span><span class=p>)</span>
        <span class=kr>then</span> <span class=kr>return</span> <span class=kc>false</span> <span class=kr>end</span>

        <span class=c1>--取出其他字段的值</span>
        <span class=kd>local</span> <span class=n>v_speed</span> <span class=o>=</span> <span class=n>buf</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
        
        <span class=c1>--现在知道是我的协议了，放心大胆添加Packet Details</span>
        <span class=kd>local</span> <span class=n>t</span> <span class=o>=</span> <span class=n>root</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=n>p_DT</span><span class=p>,</span><span class=n>buf</span><span class=p>)</span>
        <span class=c1>--在Packet List窗格的Protocol列可以展示出协议的名称</span>
        <span class=n>pkt.cols</span><span class=p>.</span><span class=n>protocol</span> <span class=o>=</span> <span class=s2>&#34;DT&#34;</span>
        <span class=c1>--这里是把对应的字段的值填写正确，只有t:add过的才会显示在Packet Details信息里. 所以在之前定义fields的时候要把所有可能出现的都写上，但是实际解析的时候，如果某些字段没出现，就不要在这里add</span>
        <span class=n>t</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=n>f_identifier</span><span class=p>,</span><span class=n>v_identifier</span><span class=p>)</span>
        <span class=n>t</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=n>f_speed</span><span class=p>,</span><span class=n>v_speed</span><span class=p>)</span>
        
        <span class=kr>return</span> <span class=kc>true</span>
    <span class=kr>end</span>
    
    <span class=c1>--这段代码是目的Packet符合条件时，被Wireshark自动调用的，是p_DT的成员方法</span>
    <span class=kr>function</span> <span class=nc>p_DT</span><span class=p>.</span><span class=nf>dissector</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>pkt</span><span class=p>,</span><span class=n>root</span><span class=p>)</span> 
        <span class=kr>if</span> <span class=n>DT_dissector</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>pkt</span><span class=p>,</span><span class=n>root</span><span class=p>)</span> <span class=kr>then</span>
            <span class=c1>--valid DT diagram</span>
        <span class=kr>else</span>
            <span class=c1>--data这个dissector几乎是必不可少的；当发现不是我的协议时，就应该调用data</span>
            <span class=n>data_dis</span><span class=p>:</span><span class=n>call</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span><span class=n>pkt</span><span class=p>,</span><span class=n>root</span><span class=p>)</span>
        <span class=kr>end</span>
    <span class=kr>end</span>
    
    <span class=kd>local</span> <span class=n>udp_encap_table</span> <span class=o>=</span> <span class=n>DissectorTable.get</span><span class=p>(</span><span class=s2>&#34;udp.port&#34;</span><span class=p>)</span>
    <span class=c1>--因为我们的DT协议的接受端口肯定是50002，所以这里只需要添加到&#34;udp.port&#34;这个DissectorTable里，并且指定值为50002即可。</span>
    <span class=n>udp_encap_table</span><span class=p>:</span><span class=n>add</span><span class=p>(</span><span class=mi>50002</span><span class=p>,</span> <span class=n>p_DT</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><p>将其保存为 <code>packet-dt.lua</code> 文件
上面这段代码已经看起来非常清楚了，如果是解析一般的自定义协议，上边的代码基本上够用了。</p><p>0x03 Lua插件的启用
想要启用Lua插件，首先要确认你的Wireshark版本是支持Lua的（Windows版本默认应该都是启用支持了的）。可以通过【帮助】-【关于】窗口确认：
<img src=https://www.zacharyjia.me/usr/uploads/2018/02/3733043128.png alt=lua支持.png></p><p>如果是这种With Lua的，应该就是可以的了。</p><p>然后去文件夹选项卡，找到Global Configuration文件夹的位置:</p><p><img src=https://www.zacharyjia.me/usr/uploads/2018/02/569570693.png alt=global-configuration.png></p><p>在这个文件夹里找到init.lua文件，使用文本文件编辑器打开它，在文件的最后添加：</p><pre><code>dofile(&quot;c:\\path\\to\\packet-dt.lua&quot;)
</code></pre><p>填写好正确的packet-dt.lua所在的位置，保存文件就可以了。
然后重新启动Wireshark或者点击【分析】-【重新载入Lua插件】，就可以启用你自己的lua插件了。</p><h1 id=0x04-测试与调试>0x04 测试与调试</h1><p>测试的话，直接抓包就可以看到对应的包的协议列变成了DT，并且Packet详情窗口里可以看到对应的协议行了。
如果出现问题，Wireshark会直接在对应位置报错，按照报错信息修改packet-dt.lua文件，保存后重新载入Lua插件就可以。</p><h1 id=0x05-高级一点的玩法>0x05 高级一点的玩法</h1><p>虽然我们实现了基本的包解析功能，但是其实我之前说过，我们的UDP的PayLoad里封装的其实是以太网包，能不能让Wireshark在我们的插件执行完之后，继续按照以太网格式解析其他部分呢？肯定是可以的。</p><p>这里，我们只需要重新构造一下需要继续解析的数据，然后获取出一个以太网解析器就可以继续做下去了：</p><div class=highlight><pre class=chroma><code class=language-lua data-lang=lua>        <span class=kd>local</span> <span class=n>raw_data</span> <span class=o>=</span> <span class=n>buf</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>buf</span><span class=p>:</span><span class=n>len</span><span class=p>()</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
        <span class=n>Dissector.get</span><span class=p>(</span><span class=s2>&#34;eth_maybefcs&#34;</span><span class=p>):</span><span class=n>call</span><span class=p>(</span><span class=n>raw_data</span><span class=p>:</span><span class=n>tvb</span><span class=p>(),</span> <span class=n>pkt</span><span class=p>,</span> <span class=n>root</span><span class=p>)</span>
</code></pre></div><p>把这段添加在刚才的 <code>t:add(f_speed, v_speed)</code>之后，就可以了。
这里要注意两点，第一点是获取的解析器名称应该是 <code>eth_maybefcs</code>，这个坑了我很久，因为DissectorTable里写的也是eth，但是提示找不到。网上查了很久之后才发现应该用这个名字去获取，意思是可能带有fcs的eth帧。。。</p><p>第二点是raw_data需要调用一下tvb()函数，不然会提示你这个是userdata，不能使用。tvb的全称应该是Testy Virtual Buffer，用来存储Packet buffer的，要处理必须先转成这个。</p><p>这样你测试的时候，就可以看到，Packet Details窗口里的"Nselab.Zachary DT"栏的下面，又出现了Ethernet、IP等，这就是内部的数据解析出来的结果。</p><p>当然，你也会发现列表的协议栏又被改成了ARP、ICMP等内部协议的名称了，这是因为调用<code>eth_maybefcs</code>解析器的时候，这些解析器又会给协议栏赋值，覆盖掉我们之前写的<code>DT</code>。为了和其他的区分，我们还可以玩得更骚气一点，在上面的代码之后加上：</p><pre><code>        pkt.cols.protocol:append(&quot;-DT&quot;)
</code></pre><p>这句话的意思就是不管协议栏被改成了啥，我都在后面加上<code>-DT</code>，这样ARP、ICMP等就会变成 <code>ARP-DT</code>、<code>ICMP-DT</code>了，一眼就可以跟那些平淡无奇的ARP和ICMP区分出来。</p><h1 id=0x06-结束语>0x06 结束语</h1><p>总的来说，使用Lua来编写Wireshark的协议解析插件还是比较简单的，相对于使用C语言，配置、开发、调试应该都方便了不少。当然，如果要详细开发，肯定还是要多看看官方的开发文档：<a class=link href=https://www.wireshark.org/docs/wsdg_html_chunked/ target=_blank rel=noopener>Wireshark Developer&rsquo;s Guide</a>.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/wireshark/>wireshark</a>
<a href=/tags/%E7%BD%91%E7%BB%9C/>网络</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-ND 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title></h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%AE%9D%E4%B8%AA%E4%BA%BA%E6%94%B6%E6%AC%BE%E7%9A%84%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/><div class=article-details><h2 class=article-title>微信、支付宝个人收款的一种实现思路</h2></div></a></article><article><a href=/p/linux%E4%B8%8B%E5%AE%89%E8%A3%85riverbed-opnet-modeler-18.6.1%E8%BF%87%E7%A8%8B/><div class=article-details><h2 class=article-title>Linux下安装Riverbed OPNET Modeler 18.6.1过程</h2></div></a></article><article><a href=/p/gitlab-ci%E4%B8%ADpip%E7%BC%93%E5%AD%98%E7%9A%84%E9%85%8D%E7%BD%AE/><div class=article-details><h2 class=article-title>gitlab-ci中pip缓存的配置</h2></div></a></article><article><a href=/p/%E4%BF%AE%E6%94%B9laravel%E8%87%AA%E5%B8%A6%E7%9A%84%E8%AE%A4%E8%AF%81%E7%B3%BB%E7%BB%9F%E7%9A%84user%E7%B1%BB%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/><div class=article-details><h2 class=article-title>修改Laravel自带的认证系统的User类的命名空间</h2></div></a></article><article><a href=/p/laravel-%E8%B7%AF%E7%94%B1%E7%BC%93%E5%AD%98/><div class=article-details><h2 class=article-title>laravel 路由缓存</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy; 2020 Zachary's Blog</section><section class=powerby><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>