<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="题目里说的个人收款指的不是普通的扫个码，而是说那种可以支持回调的，例如网上商城支付之后，商城可以知道支付状态并且自动修改订单的状态为“已支付”。这种支付的形式，无论是微信、支付宝还是银联，目前都是不对个人开放的，必须有企业资质才能申请。但是对于很多开发者而言，有时候就是一个小小的验证性应用，想要拥有支付功能，而自己又没有企业资质，自然没法申请到微信支付宝这种接口，甚至连第三方的聚合支付（Ping++）也是无法申请的。本文就介绍一种利用个人支付宝（微信也是可以的）自己实现支付功能的思路，成本是一部旧的安卓手机，其他的都是完全免费的，配合支付宝的收款码（提现免费），可以做到零费率。"><title>微信、支付宝个人收款的一种实现思路</title><link rel=canonical href=https://jiacs.com/p/thinking-on-personal-pay/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="微信、支付宝个人收款的一种实现思路"><meta property="og:description" content="题目里说的个人收款指的不是普通的扫个码，而是说那种可以支持回调的，例如网上商城支付之后，商城可以知道支付状态并且自动修改订单的状态为“已支付”。这种支付的形式，无论是微信、支付宝还是银联，目前都是不对个人开放的，必须有企业资质才能申请。但是对于很多开发者而言，有时候就是一个小小的验证性应用，想要拥有支付功能，而自己又没有企业资质，自然没法申请到微信支付宝这种接口，甚至连第三方的聚合支付（Ping++）也是无法申请的。本文就介绍一种利用个人支付宝（微信也是可以的）自己实现支付功能的思路，成本是一部旧的安卓手机，其他的都是完全免费的，配合支付宝的收款码（提现免费），可以做到零费率。"><meta property="og:url" content="https://jiacs.com/p/thinking-on-personal-pay/"><meta property="og:site_name" content="Zachary's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:published_time" content="2018-03-11T00:00:00+00:00"><meta property="article:modified_time" content="2018-03-11T00:00:00+00:00"><meta name=twitter:title content="微信、支付宝个人收款的一种实现思路"><meta name=twitter:description content="题目里说的个人收款指的不是普通的扫个码，而是说那种可以支持回调的，例如网上商城支付之后，商城可以知道支付状态并且自动修改订单的状态为“已支付”。这种支付的形式，无论是微信、支付宝还是银联，目前都是不对个人开放的，必须有企业资质才能申请。但是对于很多开发者而言，有时候就是一个小小的验证性应用，想要拥有支付功能，而自己又没有企业资质，自然没法申请到微信支付宝这种接口，甚至连第三方的聚合支付（Ping++）也是无法申请的。本文就介绍一种利用个人支付宝（微信也是可以的）自己实现支付功能的思路，成本是一部旧的安卓手机，其他的都是完全免费的，配合支付宝的收款码（提现免费），可以做到零费率。"></head><body><div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hub711587dd8549032a5441bfdfb2dc9e8_883541_300x300_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🎓</span></figure><h1 class=site-name><a href=https://jiacs.com>Zachary's Blog</a></h1><h2 class=site-description>贾泽群的个人博客</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>归档</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>搜索</span></a></li></ol></aside><main class="main full-width"><div id=article-toolbar><a href=https://jiacs.com class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E5%BC%80%E5%8F%91/>开发</a></header><h2 class=article-title><a href=/p/thinking-on-personal-pay/>微信、支付宝个人收款的一种实现思路</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Mar 11, 2018</time></footer></div></header><section class=article-content><p>题目里说的个人收款指的不是普通的扫个码，而是说那种可以支持回调的，例如网上商城支付之后，商城可以知道支付状态并且自动修改订单的状态为“已支付”。这种支付的形式，无论是微信、支付宝还是银联，目前都是不对个人开放的，必须有企业资质才能申请。但是对于很多开发者而言，有时候就是一个小小的验证性应用，想要拥有支付功能，而自己又没有企业资质，自然没法申请到微信支付宝这种接口，甚至连第三方的聚合支付（Ping++）也是无法申请的。本文就介绍一种利用个人支付宝（微信也是可以的）自己实现支付功能的思路，成本是一部旧的<strong>安卓手机</strong>，其他的都是完全免费的，配合支付宝的收款码（提现免费），可以做到<strong>零费率</strong>。</p><h1 id=一基本思路>一、基本思路</h1><p>这个方案的基本思路是非常简单的，跟之前大家常用的用爬虫爬取网页账单数据类似，但是这里我们用的是手机App。相对来说，截取手机App的推送消息更为简单，不需要应为微信支付宝的各种反爬措施；但是缺点是能够获取到的信息较少，没有诸如流水号、付款人之类的信息，只有一个金额。</p><p>所以，我们的思路就是：</p><ol><li>创建一个订单，将二维码（定额或者非定额都可以）展示给用户</li><li>用户支付后，商家手机App上收到支付宝的付款推送</li><li>安卓App截取支付宝的付款推送，然后将付款信息发送给服务器</li><li>服务器根据付款金额，确定到底是哪一笔订单，然后将该订单标记为“已付款”，然后根据需要进行回调通知之类的操作。</li></ol><h1 id=二关键问题及其解决方案>二、关键问题及其解决方案</h1><p>这个方案里的关键问题有以下几个：</p><h2 id=1支付宝app的通知截取>1.支付宝App的通知截取</h2><p>这个问题其实网上已经有很多的解决方案了，其利用的是Android中的<code>NotificationListenerService</code>这个类，通过注册这个Listener，可以在推送通知弹出来的时候，获取到其发送的App、标题、内容等信息。我们最关心的就是App和推送内容。</p><p>判断发送App的包为支付宝的包，然后再从推送的内容中获取到具体的内容，即可得到付款金额。</p><p>示例代码如下：</p><pre><code>public class AlipayNotificationListenerService extends NotificationListenerService {
    public AlipayNotificationListenerService() {
    }

    @Override
    public void onNotificationPosted(StatusBarNotification sbn) {
        // 这里可以拿到包名，可以按照需要判断。
        String packageName = sbn.getPackageName();
        Notification notification = sbn.getNotification();
        if (notification == null) {
            return;
        }
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            Log.e(&quot;SevenNLS&quot;,&quot;in 1&quot;);
            Bundle extras = notification.extras;

            if (extras != null) {
                // 这里是具体的title和content，可以从中提取金额
                String title = extras.getString(Notification.EXTRA_TITLE, &quot;&quot;);
                String content = extras.getString(Notification.EXTRA_TEXT, &quot;&quot;);
                Log.d(&quot;Zachary&quot;, &quot;title:&quot; + title + &quot;   content:&quot; + content);
            }
        }
    }

    @Override
    public void onListenerConnected()
    {
        Log.e(&quot;Zachary&quot;,&quot;connected&quot;);
    }


}

</code></pre><p>当然，为了让这个App能够顺利进行，还要给它获取通知的权限，保证它不被清理等等，需要做一些相应的保护措施。</p><h2 id=2订单的确定>2.订单的确定</h2><p>刚才我们说过，服务器收到App发来的收款信息之后，还需要找到对应的订单。这一步是相对比较难的一步，因为我们知道相同金额的订单可能有很多，到底哪一个才是刚刚支付的订单呢？</p><p>这里，我们可以再详细思考一下，其实这个订单不仅仅是由这个金额确定的，而是一个多元组共同确定的。最简单的一种实现方式就是 <strong>（订单金额-支付状态）</strong>。通过这个二元组可以确定一个订单。其含义是，如果这个订单已经支付过了，那么我在查找订单的时候，就可以不用理会它了，我只需要查找**（指定金额-未支付）**的订单就可以了。</p><p>这样可以基本解决这个问题。但是，我们考虑到除了正常支付外，还有可能会有另外一些情况。比如用户创建了订单之后，突然不想支付了，没有进行接下来的操作。或者说，有人恶意在网站上创建了大量的订单并且不支付。 这样的后果是，这些订单的状态永远都是<code>未支付</code>，当你想要继续创建订单的时候，就会受到限制，不能创建跟这些订单相同金额的订单，否则你的系统将无法分辨到底是哪一笔订单被支付了。</p><p>为了应对这种情况，我们想到其实很多的支付都是有时间限制的，也就是说，订单是有有效期的，一旦过了有效期，订单就不能被支付了。所以我们也可以给订单加一个有效时间的限制，比如5分钟，一旦五分钟内没有被支付，就认为这个订单已经失效了。这时，订单的确定方式就变成了一个三元组**（订单金额-支付状态-是否过期）**。查找的时候，只需要查找**（指定金额-未支付-未过期）**的订单就可以了。也就是说，任意一个订单，最多只会占用这个金额5分钟，一旦超过五分钟，不管支付与否，你都可以继续创建相同金额的订单了。</p><p>但是这样我们还是觉得不满意，特别是对于某些支付金额相对单一的情况，可能每次都需要创建相同金额的订单，这样的话，再最坏情况下我们只能每隔五分钟处理一个订单，这个效率可以说是非常低效了。</p><p>在这里，我们提出了一种trade-off的解决方法。一般的正常支付是不会使用这种方式的，也难以接受，但是对于我们来说，为了避免企业资质的认证和手续费，在一定程度上是可以接受的。</p><p>这种方式就是，当目前系统中已经有了某一金额的订单的时候，如果我们要继续创建相同金额的订单，那么我们就在指定金额上进行<strong>上下浮动</strong>，比如下浮一分钱，这样金额就可以和之前的订单区分开来，避免出现不能同时支付的情况。这样，虽然我们在高并发情况下可能会有一定的损失（同时支付的人越多，差距越大），但是满足了我们的高并发要求。</p><p>友情提示：如果金额发生浮动，可以告诉用户这是随机立减，一定程度上可以避免定价和实际支付金额的差距带来的问题。（这种情况下就只能下浮，不能上浮，不然就变成随机立加了）。</p><h1 id=三总结>三、总结</h1><p>总体上来说，我认为这种方案对于普通的个人用户来说，是一种可以接受的方案。其优缺点总结如下：</p><h3 id=优点>优点：</h3><ol><li>不需要企业资质</li><li>没有手续费</li><li>不对支付宝进行任何操作，没有被支付宝进行风控的风险</li></ol><h3 id=缺点>缺点：</h3><ol><li>需要有一部手机一直运行，且要求网络条件良好，否则会丢失支付数据（可以有人工解决方案）</li><li>高并发时，订单金额会产生浮动</li><li><strong>如果金额浮动策略不合理，并且被人探索出规律，可能造成财产损失！！（例如短时间内创建大量订单，这样订单价格会不断下降，需要针对这种情况做出防范）</strong></li></ol><p>参考：
PaysApi: <a href=https://www.paysapi.com>https://www.paysapi.com</a></p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-ND 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title></h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/p/wireshark-plugin-using-lua/><div class=article-details><h2 class=article-title>自己动手编写Wireshark Lua插件解析自定义协议</h2></div></a></article><article><a href=/p/linux-opnet-installation-guide/><div class=article-details><h2 class=article-title>Linux下安装Riverbed OPNET Modeler 18.6.1过程</h2></div></a></article><article><a href=/p/gitlab-ci-pip-cache/><div class=article-details><h2 class=article-title>gitlab-ci中pip缓存的配置</h2></div></a></article><article><a href=/p/laravel-user-namespace/><div class=article-details><h2 class=article-title>修改Laravel自带的认证系统的User类的命名空间</h2></div></a></article><article><a href=/p/laravel-routing-cache/><div class=article-details><h2 class=article-title>laravel 路由缓存</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=ZacharyJia/ZacharyJia.github.io issue-term=pathname theme=preferred-color-scheme label=Comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><footer class=site-footer><section class=copyright>&copy; 2021 Zachary's Blog</section><section class=powerby><br></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>