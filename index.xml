<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Zachary's Blog</title><link>https://blog.zacharyjia.me/</link><description>Recent content on Zachary's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 28 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.zacharyjia.me/index.xml" rel="self" type="application/rss+xml"/><item><title>Floyd判圈算法（龟兔赛跑算法）</title><link>https://blog.zacharyjia.me/p/floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95/</link><pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate><guid>https://blog.zacharyjia.me/p/floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95/</guid><description>&lt;h2 id="问题">问题：&lt;/h2>
&lt;p>如何判断一个链表是否有闭环？&lt;/p>
&lt;p>今天看到了这个问题，提到了Floyd判圈算法，于是去查了一下这个算法，把自己的一点想法写下来。&lt;/p>
&lt;h3 id="问题的答案是">问题的答案是：&lt;/h3>
&lt;p>从链表的头部设置两个指针，p1的步长为1， p2的步长为2，同时向前走，如果p1和p2最终能够相遇，则说明链表是有环的。&lt;/p>
&lt;p>检测环的基本思想是非常简单的，可以类比成两个人在跑道上跑。只要有圈，跑的快的那个人就一定能够追上跑得慢的那个人。&lt;/p>
&lt;p>另外，还有两个相关的问题，一个是如何求环的长度，另一个是如何求环的起点。&lt;/p>
&lt;h3 id="求环的长度">求环的长度&lt;/h3>
&lt;p>这个也能非常简单的想到：&lt;/p>
&lt;p>两个人相遇的是时候，一定已经在环上了，然后两个人只要再次在环上接着跑，再次相遇的时候（也就是所谓的套圈），跑的快的那个人就比跑得慢的人整整多跑了一圈，所以环的长度也就出来了。&lt;/p>
&lt;p>用算法来描述，也就是第一次相遇后，p1和p2按照原来的步长继续向前查找，并且记录下两个指针遍历过的节点个数。当两个指针再次相遇的时候，遍历的节点数量差就是环的长度了。&lt;/p>
&lt;h3 id="第二个就是求环的起点">第二个就是求环的起点&lt;/h3>
&lt;p>解决方法是把其中的一个指针重置到链表头部，然后两个指针步长都为1，继续向前移动，相遇的位置即为环的起点。&lt;/p>
&lt;p>方法的解析如下：
首先我们设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m, 环的长度为n，相遇的位置与起点位置距离为k。
则可以得到:
&lt;code>i = m + a * n + k&lt;/code>&lt;/p>
&lt;p>其中a为慢指针走的圈数。
根据快指针和慢指针的速度关系，我们可以得到另一个式子:
&lt;code>2 * i = m + b * n + k&lt;/code>&lt;/p>
&lt;p>其中b为快指针走的圈数。
简单处理得到:
&lt;code>i = (b - a) * n&lt;/code>&lt;/p>
&lt;p>也就是说i是圈长的整数倍。
这时将其中一个节点放到起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点&lt;code>i + m&lt;/code>, i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。&lt;/p></description></item><item><title>NSCTF2015部分题目解析</title><link>https://blog.zacharyjia.me/p/nsctf2015%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</link><pubDate>Sun, 04 Oct 2015 00:00:00 +0000</pubDate><guid>https://blog.zacharyjia.me/p/nsctf2015%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</guid><description>&lt;p>前段时间做了NSCTF的比赛，做出了其中的几道题目，下面对几道题目的解题过程进行简单的分析。&lt;/p>
&lt;h2 id="1-crypto50-神奇的字符串">1. Crypto50 神奇的字符串&lt;/h2>
&lt;h3 id="题目">题目：&lt;/h3>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgcrypto50.png" alt="crypto50" />&lt;/p>
&lt;h3 id="解题过程">解题过程：&lt;/h3>
&lt;p>观察题目中的字符串，应该是进行了加密之后得到的字符串。利用网上的解密工具进行Base64解密，AES解密等解密工具以后发现，是使用了AES进行了加密。解密后的密文为：&lt;/p>
&lt;blockquote>
&lt;p>flag{DISJV_Hej_UdShofjyed}&lt;/p>
&lt;/blockquote>
&lt;p>根据NSCTF的flag规则，flag应该是以**“NSCTF_”**开头的，而解密后得到的结果的前几位是**“DISJV”**,
猜测是否使用了最常见的移位方法进行了加密。
于是进行一下验证，首先将DISJV几个字母与NSCTF对应&lt;/p>
&lt;pre>&lt;code>原：ABCDEFGHIJKLMNOPQRSTUVWXYZ
移： S V D IJ
&lt;/code>&lt;/pre>&lt;p>进行补全后如下：&lt;/p>
&lt;pre>&lt;code>原：ABCDEFGHIJKLMNOPQRSTUVWXYZ
移：QRSTUVWXYZABCDEFGHIJKLMNOP
&lt;/code>&lt;/pre>&lt;p>发现能够完全对应。于是将flag中剩下的字母按照大小写进行对应，最终得到最后的flag：&lt;/p>
&lt;blockquote>
&lt;p>NSCTF_Rot_EnCryption&lt;/p>
&lt;/blockquote>
&lt;h2 id="2-web200-decode">2. Web200 Decode&lt;/h2>
&lt;h3 id="题目要求">题目要求：&lt;/h3>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgweb200Decode.png" alt="web200Decode" />
本题目的要求比较简单，是针对一个已经给出源代码的PHP加密函数，解密加密后的密文。&lt;/p>
&lt;h3 id="解题过程-1">解题过程：&lt;/h3>
&lt;p>根据题目要求，只需要弄懂加密代码中的使用的几种加密方法即可。&lt;/p>
&lt;p>要解密文，只需要按照与加密顺序相反的顺序进行解密即可。&lt;/p>
&lt;p>首先分析源代码，我们可以看到最后进行的操作是&lt;code>str_rot13&lt;/code>这个函数。我们查看这个函数的介绍：&lt;/p>
&lt;pre>&lt;code>str_rot13() 函数对字符串执行 ROT13 编码。
ROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。
提示：编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。
&lt;/code>&lt;/pre>&lt;p>从这里我们可以清楚地知道，rot13编码的加密和解密函数其实是同一个函数，只要对密文再进行一遍rot13编码即可解密。因此我们的第一步就是再次调用&lt;code>str_rot13&lt;/code>函数，处理密文。&lt;/p>
&lt;p>然后，我们可以看到倒数第二步进行的操作是&lt;code>strrev&lt;/code>函数，这个函数是对字符串进行反转，也就是倒序输出。很明显，要还原密文，只需要再次调用&lt;code>strrev&lt;/code>函数对上一步的密文进行处理即可。&lt;/p>
&lt;p>接着，我们发现加密算法还对密文进行了base64加密，只需要调用&lt;code>base64_decode&lt;/code>函数就可以解密。&lt;/p>
&lt;p>接着，我们再来分析上面的for循环中的内容。从for循环上面的语句来看，我们知道$_o中的字符串应该是原文的倒序。
然后我们来看for循环对$_o这个函数进行了怎样的操作:&lt;/p>
&lt;p>第一步是看循环的次数，我们可以清楚的看出是循环了&lt;code>strlen($_o)&lt;/code>次，也就是与$_o的长度等长。
然后&lt;code>$_c = substr($_o, $_O, 1)&lt;/code>这个是从字符串的第$_O个位置截取1个字符出来，赋值给$_c。
接着&lt;code>$__ = ord($_c) + 1&lt;/code>和&lt;code>$_c = chr($__)&lt;/code>两句的意思是，先将刚才的字符转换为ascii码，加1以后再转回字符。
最后再把这个新的字符挨个连接起来生成$_这个变量。&lt;/p>
&lt;p>综合来看，其实就是将原文中所有的字符都加1。那我们要解密的话也可以使用类似的方法，对密文中所有的字符循环减1。这样就得到了$_o中的内容。&lt;/p>
&lt;p>然后我们说过,$_o和$str中的数据是相互逆序的关系，我们只需要再对$_o进行一遍逆序，就可以得到原文了！&lt;/p>
&lt;p>以下是解密函数的代码：&lt;/p>
&lt;pre>&lt;code>&amp;lt;?php
$sec = &amp;quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&amp;quot;;
$sec = str_rot13($sec);
$sec = strrev($sec);
$sec = base64_decode($sec);
for($i = strlen($sec) - 1; $i &amp;gt;= 0; $i--)
{
$c = substr($sec, $i, 1);
$__ = ord($c) - 1;
$c = chr($__);
$_ = $c.$_;
}
echo strrev($_);
?&amp;gt;
&lt;/code>&lt;/pre>&lt;p>在php服务器上执行以上代码，就可以得到原文。&lt;/p>
&lt;h2 id="3misc250-wireshark">3.MISC250 WireShark&lt;/h2>
&lt;h3 id="题目要求-1">题目要求：&lt;/h3>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgwireshark.png" alt="wireshark" />&lt;/p>
&lt;h3 id="解题思路">解题思路：&lt;/h3>
&lt;p>首先根据题目的描述，使用wireshark打开下载到的文件。题目中描述，这里面有室友下载的小东东。
既然是下载的内容，首先考虑的就是HTTP协议和FTP协议，然后在记录中查找可以找到下面的记录。&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgwireshark2.png" alt="wireshark2" />&lt;/p>
&lt;p>划红线的部分可以看到，用户下载了一个key.rar的文件。然后我们找到下面一个从服务器发来的包，就可以找到key.rar的文件的内容。
将数据dump到文件中发现，是一个加密的rar文件。&lt;/p>
&lt;p>继续在抓到的包中寻找发现，在rar之前的http包中发现，用户还浏览过一个html文件，使用相同的方式将html文件保存下来，打开后发现文件内容大概是这样：&lt;/p>
&lt;blockquote>
&lt;p>密码是nsfocus+5位数字&lt;/p>
&lt;/blockquote>
&lt;p>接下来就只能使用暴力破解了，这里我使用的是ARCHPR 4.54这个软件，但是由于密码规则比较特殊，前几位是固定的字母，而最后五位是数字，使用其默认的规则有些困难。
因此，我手动编写了一个小程序，将所有nsfocus+5位数字的可能性全部输出到了一个文件里，将这个文件作为字典文件，使用字典类型的破解，最终获取了密码，然后得到了该文件中的flag。&lt;/p>
&lt;h2 id="4misc400-小绿的女神">4.MISC400 小绿的女神&lt;/h2>
&lt;h3 id="题目要求-2">题目要求：&lt;/h3>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgcard.png" alt="card" />&lt;/p>
&lt;p>这个题目有点特殊，是上传一个card文件，模拟刷卡，然后可以在网页上模拟消费和查询余额两个操作。&lt;/p>
&lt;h3 id="解题过程-2">解题过程：&lt;/h3>
&lt;p>拿到这个题目，首先上传card文件上去，然后点击查询余额，发现显示了余额，并且页面中显示了card文件的16进制内容，然后再次进行刷卡操作，提示消费了**元，并且更新了显示的card的内容。
注意到操作前后显示的内容是不同的， 因此可以猜测，变化的部分就是存储卡的余额的相关部分。
使用文件对比工具，比较一下变化的内容：&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgcard2.png" alt="card2" />&lt;/p>
&lt;p>可以看到0x40和0xC0那两行有变化。再次仔细对比可以发现，0xC0~0xC3部分表示的是当前余额：&lt;/p>
&lt;p>余额为 96.41， 0xC0~0xC3部分内容为 A9 25 00 00。应该是按照内存中数据的存储方式，高位数据在内存地址大的位置。也就是说其值应该为00 00 25 A9,即9641。&lt;/p>
&lt;p>而0xC4~0xC7部分是0xFFFFFFFF减去余额。
直接修改该部分和其后相同的部分发现，系统提示不通过，也就是卡片内容修改之后不能通过系统的验证了。继续观察发现：
继续观察发现，另一部分发生变化的0x40~0x43与0xC0~0xC3部分的和是不变的！&lt;/p>
&lt;p>将两部分对应好之后修改发现，卡片的余额确实发生了变化，但是不能达到预期的数字。因为即使把0x40~0x43部分改成0，也不能余额达到208那么大的数字。也就是说这两部分的总和根本就不到208，只修改这两部分肯定不能达到要求。&lt;/p>
&lt;p>这是我们继续观察发现，0x80那一行的数据也与其他为00的数据不同，肯定与其他数据有关联。经过计算发现，0x80那一行的数据就是0x40和0xC0的和，0x80的数据就是卡片的总和！
这样就很简单了，只需要将0x80那一行的数据改成足够大，然后把0xC0部分修改为 40 51 00 00 (其他部分相应修改)就可以查询到208的余额了！然后就能看到弹出的flag了。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgscore2.png" alt="score2" />&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgscore.png" alt="score" />&lt;/p>
&lt;p>本次比赛中我共得到了1200分，虽然做出了一部分的题。但是感觉做起来比较艰难，在Web、逆向等方面的经验和能力明显不足，希望以后能够不断积累经验提高自己的水平。&lt;/p></description></item><item><title>8086汇编开发环境搭建</title><link>https://blog.zacharyjia.me/p/8086%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link><pubDate>Sun, 27 Sep 2015 00:00:00 +0000</pubDate><guid>https://blog.zacharyjia.me/p/8086%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid><description>&lt;p>本学期开始学习汇编了，但是无奈学的东西都是好久之前的老知识了，在现在的电脑上实践起来略有困难，连&lt;code>debug&lt;/code>命令都没法用。
最后在参考老师给的资料和网上相关资料的基础上，完成了汇编开发环境的搭建，做下记录，以备后用。&lt;/p>
&lt;p>整个开发环境的搭建主要有以下几步：&lt;/p>
&lt;ol>
&lt;li>Dos模拟器DosBox的安装和本地文件夹的挂载&lt;/li>
&lt;li>masm、link、debug等工具的安装&lt;/li>
&lt;li>环境变量的配置&lt;/li>
&lt;li>自动运行脚本的配置&lt;/li>
&lt;/ol>
&lt;p>以上是基本步骤。文中所用到的各个软件可以在&lt;a class="link" href="http://qn-cdn.zacharyjia.me/file%e6%b1%87%e7%bc%96%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba.zip" target="_blank" rel="noopener"
>这里&lt;/a>下载&lt;/p>
&lt;p>下面开始正式的安装和搭建过程。&lt;/p>
&lt;h3 id="0x0-dos模拟器dosbox的安装和本地文件夹的挂载">0x0. Dos模拟器DosBox的安装和本地文件夹的挂载&lt;/h3>
&lt;p>从上面的压缩包中找到DosBox的安装文件，安装即可。安装完成后可以桌面或者开始菜单的图标打开DosBox.如下图：&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgDosBox.png" alt="DosBox" />&lt;/p>
&lt;p>可以看到它默认的系统盘是Z盘。
下面我们可以通过以下命令将本地电脑的一个文件夹挂载到DosBox中：&lt;/p>
&lt;pre>&lt;code>mount c e:\masm611
&lt;/code>&lt;/pre>&lt;p>这条命令的含义就是将本地的&lt;code>e:\masm611&lt;/code>这个文件夹挂载到DosBox中的C盘里。
也就是说你在DosBox中访问C盘的资源就可以看到这个文件夹中的内容了。
可以通过&lt;/p>
&lt;pre>&lt;code>c:
dir
&lt;/code>&lt;/pre>&lt;p>这两条命令查看到其中的内容。&lt;/p>
&lt;h3 id="0x1-masmlinkdebug等工具的安装">0x1. masm、link、debug等工具的安装&lt;/h3>
&lt;p>我们在进行汇编编程的过程中，上面说的这几个工具都是非常常用的。Masm是编译器，link是链接器，debug是用来调试程序的。&lt;/p>
&lt;p>首先我们来安装masm，这里我使用的是Masm6.11的安装版，我没有尝试过只使用一个masm.exe文件是否能够成功，可以自行尝试。
把压缩包中的Masm611.zip中的几个文件夹解压到刚才挂载的文件夹中（e:\masm611），然后从DosBox中进入DISK1文件夹，运行其中的setup.exe:&lt;/p>
&lt;pre>&lt;code>cd DISK1 回车
setup 回车
&lt;/code>&lt;/pre>&lt;p>这时你就可以看到上古时代的软件安装界面了^_^&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%85.png" alt="安装" />&lt;/p>
&lt;p>按照提示首先按回车继续，然后选择&lt;code>Install the Macro Assembler using defaults&lt;/code>：&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%852.png" alt="安装2" />&lt;/p>
&lt;p>然后选择安装位置，我们选择刚刚挂载的C盘。&lt;/p>
&lt;p>然后确认我们的选择。我们选择&lt;code>NO CHANGES&lt;/code>继续安装即可。&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%853.png" alt="安装3" />&lt;/p>
&lt;p>最后等待一会儿之后就可以安装完成了。（确实要等&lt;em>一会儿&lt;/em>）&lt;/p>
&lt;p>回到命令输入界面后，我们可以通过cd命令进入到&lt;code>c:\masm611\bin&lt;/code>这个目录，然后通过dir命令查看所有文件，如果你能找到
&lt;code>masm.exe&lt;/code>这个文件，那么你这一步你就成功了。&lt;/p>
&lt;p>接着我们安装link和debug工具。其实不算安装，只要在windows中将压缩包里的两个exe文件复制到&lt;code>E:\masm611\masm611\bin&lt;/code>这个文件夹里就可以了。
然后在DosBox里再次查看&lt;code>c:\masm611\bin&lt;/code>这个目录，能看到刚复制进去的两个文件就OK了。如果看不到的话，就执行下面这条命令再查看：&lt;/p>
&lt;pre>&lt;code>rescan
&lt;/code>&lt;/pre>&lt;p>这条命令是用来清除磁盘缓存的。&lt;/p>
&lt;p>最后，你的文件夹里应该是这样的：&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgbin.png" alt="bin" />&lt;/p>
&lt;h3 id="0x2-环境变量的配置">0x2. 环境变量的配置&lt;/h3>
&lt;p>我们现在已经可以使用使用masm、Link、debug这些命令进行汇编的编程了，但是每次都要输入全路径很麻烦，所以要通过配置环境变量来简化我们的操作。
相信学习过java开发的人都了解环境变量的作用了。在dos下设置环境变量只需要一条命令就行：&lt;/p>
&lt;pre>&lt;code>set PATH=%PATH%;c:\masm611\bin\;
&lt;/code>&lt;/pre>&lt;p>也就是在原来的PATH的基础上，再加入c:\masm611\bin这个路径，也就是我们的masm等文件所在的路径。
执行完上面的命令之后，你应该就可以直接在里面输入:&lt;/p>
&lt;pre>&lt;code>masm
&lt;/code>&lt;/pre>&lt;p>来运行masm程序了。like this:&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgmasm.png" alt="masm" />&lt;/p>
&lt;p>这样这一步也成功完成了。&lt;/p>
&lt;h3 id="0x3-自动运行脚本的配置">0x3. 自动运行脚本的配置&lt;/h3>
&lt;p>到这里，其实你已经可以愉快的开发了。然而当你下次再打开DosBox的时候，你会发现：&lt;/p>
&lt;pre>&lt;code>&amp;quot;WTF？C盘怎么不见了！？&amp;quot;
&amp;quot;我的masm命令怎么运行不了了？！&amp;quot;
...
&lt;/code>&lt;/pre>&lt;p>这是因为你刚才做的配置都不能保存，关闭DosBox之后就都没了~_~
为了解决这个问题，我们可以对DosBox进行配置，让它在每次启动的时候自动为我们执行上面的操作。&lt;/p>
&lt;p>在打开DosBox的时候，你应该会看到除了DosBox的窗口之外，还启动了另一个命令行窗口。&lt;/p>
&lt;p>&lt;img src="http://qn-cdn.zacharyjia.me/imgconfig.png" alt="config" />&lt;/p>
&lt;p>然后我画红线的位置就是配置文件所在的地方，使用文本(ji)编(shi)辑(ben)器打开这个文件，然后找到最后的[autoexec]部分，在后面追加以下命令：&lt;/p>
&lt;pre>&lt;code>mount c e:\masm611
set PATH=%PATH%;c:\masm611\bin\;
&lt;/code>&lt;/pre>&lt;p>别忘记保存。这时，你再重新打开DosBox试试，发现启动完成之后，它已经自动执行了这两条命令了。这时就可以直接使用masm等命令了！&lt;/p>
&lt;h3 id="0x4-备注">0x4. 备注&lt;/h3>
&lt;p>我的安装过程中并没有在DosBox安装文本编辑器来编辑代码，因为我不想在Dos的命令行中写代码。
代码可以直接在e:\masm611这个文件夹中写，然后进DosBox编译链接调试就行，我相信大家还是更爱windows下的文本编辑器吧。&lt;/p>
&lt;p>当然如果你非要在Dos下编辑文件的话，可以去网上找一个Dos下的edit.exe复制到DosBox里面使用。&lt;/p></description></item></channel></rss>