[{"content":"《深度工作》这本书的作者的主业也是计算机领域进行科研，但是他在提高效率这方面的思考与实践着实让我羡慕。\n上个月就开始看这本书了，但是读了一半又颓废地扔了下来。今天终于重新拿了起来，一口气读完。下面记录了我根据自己的印象回忆出来的书里的一些锻炼深度工作的方法，应该是让我比较有收获、想尝试的一些。\n 不要在工作时间段之外工作，严格规定好自己的工作时段。一般人能够集中精神进行工作的上限是4个小时，因此只要能够保证工作的深度，那么不需要额外的加班也能够完成相当充实的工作内容。 认真规划自己工作时段的每一分钟。在一天开始的时候，规划好自己当天工作时段的每一个时段的工作内容。但是这种规定并不是死板的，当出现意外情况打断自己的计划时，那么在接下来的空闲时间内重新规划自己的工作内容。刚开始的时候，由于自己对时间和任务的预估并不是很准确，可能会需要进行多次重新规划。但是1）随着锻炼的深入，对于工作量的预估会越来越准确，2）可以学会预留出一定的时间段来让时间更有弹性。 设定离线/在线时间，在离线时间范围内，严禁使用网络。即使在离线时段内，因为无法使用网络，而造成了停顿，也不要马上放弃离线时段。如果确认确实由于网络而无法继续工作，那么等待5分钟，开始在线时段，并且调整接下来的离线/在线时段安排。 不要频繁地切换工作内容。注意力残留现象：在进行任务切换时，上一个任务仍然会对新的任务有残留的影响。 并且上一个任务的完成程度越低（或者说在进行上一个任务时的专注程度越低），注意力残留的影响就越大。因此频繁切换工作任务，会降低自己的工作效率。此外，在有干扰的状态下工作，对我们的表现是有潜在危害的。特别是收到一些无法立即完成的任务打扰时，这种干扰带来的注意力残留对我们的表现十分有害。 当一天的工作时段结束时，进行停工仪式。如果直接停止工作，那么就会在大脑中残留关于未完成工作的一些内容，打破工作时段限制。在每天的工作时段即将完成时，花费一些时间进行停工仪式：1）最后看一眼电子邮箱，确保没有任何需要紧急回复的信息；2）将头脑中或随手记下的所有新任务转移到办公任务列表中；3）然后迅速浏览每一个任务，再检查一下日程表之后几天的安排。从而保证不会忘记任何紧急事情、重要的截止日期或即将到来的预约。 给自己设立一个随时能够看到的计分板，记录自己深度工作的时段。 不要使用网络来消遣。即使是自己的消遣时间段，也要提前安排好要做的事情。“如果在你全部的清醒时间，都能给自己的大脑找到有意义的事情去做，而不是放任自己在迷糊的状态下漫无目的地浏览几个小时网页，那么在一天结束时，你会觉得更加充实，第二天开始时更加轻松。” ","date":"2020-05-24T00:00:00Z","permalink":"https://jiacs.com/p/deep-work/","title":"《深度工作》——如何锻炼深度工作，我的回忆与思考"},{"content":"作为一个工具控，总是想找一件趁手的文献管理工具，在各种工具之间摇摆不定，甚至还有自己动手写一套的计划。在折腾了好久之后，最终还是又落入了Readcube Papers的魔爪当中（心疼我的钱包）。\n  Readcube.png \n下面就按照我自己的一些需求和选择来聊一聊我对各种文献管理软件的优缺点的看法吧。内容按照我自己的需求来整理，主观性较强，请自行斟酌采纳。\n按照时间顺序来说，最早使用过的文献管理工具是Zotero，但是那个时候还没怎么深入接触过科研，只是单纯的体验工具。后来使用了苹果系专用的Papers3，整体界面非常现代，符合Mac软件的审美，对比Zotero还有Mendeley等软件在Mac上面的UI，真的是吊打。后面又在Zotero、Mendeley、Papers3、Readcube Papers之间反复摇摆不定，也看别人的推荐考虑过Endnote、Citavi等其他软件，后面也不了了之。\n先说一下我的情况吧：\n 平台：主要工作平台是Mac，有iPad2018，希望能够在iPad2018上面进行PDF的阅读和标记，偶尔可能会用iPhone临时看一下，极少数紧急情况下才会用Windows 文献范围：论文基本上都是英文，对中文需求不大，很少涉及到中文论文 论文写作：偏爱Latex进行论文写作，使用BibTex，也存在使用Word的情况 内容同步：要求能够多端同步（至少Mac和iOS端要能够同步），能够接受云同步，鉴于软件厂商云平台的网络不稳定性和容易跑路性，更希望能够自行部署服务端或通过第三方存储服务商（iCloud、Dropbox、OneDrive等）进行同步 PDF识别：能够根据上传的PDF文件，自动识别文献的Meta信息，自动填写 PDF阅读：最好能够支持在第三方软件（PDF Expert）上进行阅读，同时在外部软件上做的标记能够更新到软件中 价格：能够接受付费     功能 Readcube Papers Papers3 Zotero Mendeley     Mac端软件 Beta，目前没见到 有（不再功能更新） 有 有   iOS端软件 有 有（长时间未更新，不支持全面屏） 无（只有第三方） 有   其他平台 Win(Beta)/Web 无 Win Win/Linux   同步 自带云端存储（慢） 本地局域网同步，可以通过Dropbox同步 自带云存储（慢），免费300M，PDF文件支持WebDav同步 自带云存储（慢）   PDF识别 英文支持 英文支持 英文支持 英文支持   引用导出 支持 支持 支持 支持   外部PDF阅读 不支持 桌面端支持，移动端不详 桌面端支持，无移动端 桌面端支持，iOS端貌似不支持   UI美观 好 好 差 差   价格 $36/year $49买断，不再更新 免费，超出300M，$20/year(2G) 免费    表格可能显示得不是很好，下面是图片版\n  图片版 \n上表只列出了一些我比较关注的方面的比较，其他文献分类等基本功能各个软件大同小异，基本差别不大。\n在挖坑ZRef自己写了一个然后使用一段时间之后，还是因为开发工作太过繁琐弃坑了（或者可能留到后面再填坑）。最后思考再三之后还是决定了付费Readcube Papers，虽然桌面App还没有放出来不过Web端也凑合能用了，临时出问题开个爬墙器也行吧。\n来回折腾完之后，终于不用每次想读论文的时候，先被文献管理软件劝退，然后到处找软件，把以前做过的比较再重新做一遍了。\n","date":"2019-08-23T00:00:00Z","permalink":"https://jiacs.com/p/citation-manager/","title":"文献管理工具的来回折腾"},{"content":"论文写不下去，来写一写雅思经验吧 考完之后，不少人想问问我经验，我当时觉得也没啥经验好分享的，毕竟我也准备的不怎么充分 不过想了想，还是说说自己的经历吧，给大家参考。不过每个人情况不同，请各位自行斟酌，不要怪我误人子弟。\n先说一下我自己的情况吧，大一考完了四六级，四级570左右，六级540左右。大四的时候考过两次PETS5, 分数是68+3和67+4。再就是这次雅思了，本来打算晚点考，后来发现博英可以用雅思免修，就火急火燎地报考了开学前能出成绩的8月18号的考试，结果就剩了不到一个月的准备时间。 最终成绩是 听力7.5，阅读7.5，写作7.0，口语6.0\n下面说说各个科目吧。\n1. 阅读 其实我阅读没怎么准备，因为刚开始模拟的时候，用的剑12，我发现自己的模拟成绩还是挺高的，基本上都在7.5到8.5左右，做了几次都不是很差，所以就放弃在阅读上浪费时间了。 简单说一下阅读的做题方法吧。我用的方法是先快速阅读一遍全文，了解这篇文章大概在讲什么，每一段大概在讲什么，然后再看题，回头找答案做题。通读了全文之后，定位答案的时候就会快很多，大部分情况下能很快确定是哪一段，或者在某几段之间，然后再细读文章的细节。通读的时候有遇到不是很清楚的部分不要担心，反正最后这一部分也不一定考，看过去就好了，最后考到了再去细读分析。 还有阅读做题的时候一定要注意时间，很多人都会说阅读做不完题，导致最后蒙好几道，那成绩肯定好不了。我模考的时候用的是《雅思哥》的PC客户端，上面有免费的剑4到剑13的模考，不介意机考的同学可以用这个软件模拟。模考的时候可以清楚地看到剩余时间，方便你对自己的阅读速度有一定的了解。我属于通读的时候速度比较快的，所以模考的时候一般大概能剩5分钟到十几分钟不等的时间。但是在考场上可能会受到考题难度和自己的考试状态的影响，所以会有波动，我考试的时候时间就稍微有点紧张，差点做不完题。所以建议平时训练的时候一定要掐着表练习，提高阅读的速度。\n2. 听力 相对于阅读，我的听力比较差，模考的时候基本上比阅读低1分左右吧。所以后期我做模拟题基本上都是只做听力，不做阅读了。我是从剑12开始往前练，最后剩下剑13考试前练的。练了几套题之后还是略有提高的，刚开始的时候最低只有5.5分，后来能到7分左右了。 除了模考之外的练习材料用了大家都推荐的《雅思王听力语料库》，从第三章开始听写，但是我基本上只过了一遍，具体的效果我也不知道有多大。而且她的听力材料到后期词组的时候，间隔根本就不够，所以没办法自己写了一个拆分软件，可以把原来的听力材料按照词组切分开，然后自己调整播放间隔（嗯，其实就是为了逃避复习） 听力我觉得还是多听听多练练，雅思的听力是有套路的，四篇听力材料基本上每次的主题都变化不大，稍微换了一下场景而言。比如第一篇基本上都是预定场地、参加活动、预定旅行社之类的，所以大致上会有什么类型的问题也可以总结出来。 另外拼写很重要，我觉得雅思王听写的时候给我的一个很重要的帮助就是我发现其实有挺多单词虽然我认识，但是拼写的时候反而不能准确拼写了，所以还是要多写写。\n3. 写作 讲真写作我也不知道为啥会有这么高的分哈哈哈，感觉自己就是瞎写的，而且似乎还有语法错误来着。 我的写作用的材料就是买的《雅思哥》的作文范文，一共六十几篇还是八十几篇来着，当然我也没时间都看完。我刚开始的时候背了几篇，后来发现速度太慢就放弃了。后期就是看范文，把里面觉得挺好的句子勾出来记一下。还有就是要看思路，因为据说雅思的写作给分的时候还是挺看重思路的，不能泛泛而谈要言之有物。很多话题的理由呀、原因呀、措施呀，需要针对不同的话题积累一下。雅思哥范文的好处是他会给一个大纲，你可以非常清楚地看到这篇文章里用到了什么样的观点、理由、措施之类的。我最后的题目就是教育类的，幸好我之前社会类和教育类看的最多，可能也是沾了这个光。 写作的小作文我一开始也很头疼，第一次看例题的时候发现小作文是地图题，一脸懵逼根本不知道该说啥。后来看作文范文，大体上明白了描述的角度就知道该怎么挖掘图表的信息了。另外就是我把小作文范文里常用的各种形容词汇都整理下来了，比如增长有几种说法，平缓的增长怎么说，剧烈增长怎么说，波动又怎么说，地图题里的面积减少该用啥等等，因为我自己词汇量比较缺乏，所以就捡这些很容易用上的补充一下。最后考试的时候也是遇到了地图题，虽然大家似乎都很头疼，但是我觉得我还是啰嗦了挺多上去hhh 关于写作还有一点就是避免重复，看范文的时候我就发现，人家范文里可以把一个东西变着花样地说出来。因为写作特别是大作文都是围绕一个话题来描述的，所以不可避免地会用到很多次相同意思的词汇，以前写作就是一个词组或者名词反复用，有时候一篇文章里七遍八遍都不止。但是后来发现人家就算对于同样一个事物，也会变换词汇变换角度来描述，比如谈到孩子们玩游戏，对于孩子本身的描述就可以用 the young, youngster,children等等，但是有时候想不到这么多或者不知道这么多，也可以换个角度，比如players 之类的，总之就是避免一个词汇或者词组翻来覆去地用。\n4.口语 口语我是真没什么准备，连跟人模考都没有过，所以只能说说教训。 没有准备话题卡直接导致我考完之后就觉得自己要炸了，因为part2都没说满时间，而且这个考官也不像其他考官一样提个问题让你继续说，他就跟我大眼瞪小眼地等到了part2 结束 另外我回答问题的时候都很“简短”，我考完之后回想起来就觉得自己跟考官仿佛在一问一答，包括part3也没有答出什么深度。但是准备话题卡似乎也不一定沾光，据说被发现在背材料就会被压分压到很低，所以建议大家还是就当正常交流比较好。\n","date":"2018-09-06T00:00:00Z","permalink":"https://jiacs.com/p/ielts-conclusion/","title":"雅思考试经验总结"},{"content":"题目里说的个人收款指的不是普通的扫个码，而是说那种可以支持回调的，例如网上商城支付之后，商城可以知道支付状态并且自动修改订单的状态为“已支付”。这种支付的形式，无论是微信、支付宝还是银联，目前都是不对个人开放的，必须有企业资质才能申请。但是对于很多开发者而言，有时候就是一个小小的验证性应用，想要拥有支付功能，而自己又没有企业资质，自然没法申请到微信支付宝这种接口，甚至连第三方的聚合支付（Ping++）也是无法申请的。本文就介绍一种利用个人支付宝（微信也是可以的）自己实现支付功能的思路，成本是一部旧的安卓手机，其他的都是完全免费的，配合支付宝的收款码（提现免费），可以做到零费率。\n一、基本思路 这个方案的基本思路是非常简单的，跟之前大家常用的用爬虫爬取网页账单数据类似，但是这里我们用的是手机App。相对来说，截取手机App的推送消息更为简单，不需要应为微信支付宝的各种反爬措施；但是缺点是能够获取到的信息较少，没有诸如流水号、付款人之类的信息，只有一个金额。\n所以，我们的思路就是：\n 创建一个订单，将二维码（定额或者非定额都可以）展示给用户 用户支付后，商家手机App上收到支付宝的付款推送 安卓App截取支付宝的付款推送，然后将付款信息发送给服务器 服务器根据付款金额，确定到底是哪一笔订单，然后将该订单标记为“已付款”，然后根据需要进行回调通知之类的操作。  二、关键问题及其解决方案 这个方案里的关键问题有以下几个：\n1.支付宝App的通知截取 这个问题其实网上已经有很多的解决方案了，其利用的是Android中的NotificationListenerService这个类，通过注册这个Listener，可以在推送通知弹出来的时候，获取到其发送的App、标题、内容等信息。我们最关心的就是App和推送内容。\n判断发送App的包为支付宝的包，然后再从推送的内容中获取到具体的内容，即可得到付款金额。\n示例代码如下：\npublic class AlipayNotificationListenerService extends NotificationListenerService { public AlipayNotificationListenerService() { } @Override public void onNotificationPosted(StatusBarNotification sbn) { // 这里可以拿到包名，可以按照需要判断。 String packageName = sbn.getPackageName(); Notification notification = sbn.getNotification(); if (notification == null) { return; } if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT) { Log.e(\u0026quot;SevenNLS\u0026quot;,\u0026quot;in 1\u0026quot;); Bundle extras = notification.extras; if (extras != null) { // 这里是具体的title和content，可以从中提取金额 String title = extras.getString(Notification.EXTRA_TITLE, \u0026quot;\u0026quot;); String content = extras.getString(Notification.EXTRA_TEXT, \u0026quot;\u0026quot;); Log.d(\u0026quot;Zachary\u0026quot;, \u0026quot;title:\u0026quot; + title + \u0026quot; content:\u0026quot; + content); } } } @Override public void onListenerConnected() { Log.e(\u0026quot;Zachary\u0026quot;,\u0026quot;connected\u0026quot;); } } 当然，为了让这个App能够顺利进行，还要给它获取通知的权限，保证它不被清理等等，需要做一些相应的保护措施。\n2.订单的确定 刚才我们说过，服务器收到App发来的收款信息之后，还需要找到对应的订单。这一步是相对比较难的一步，因为我们知道相同金额的订单可能有很多，到底哪一个才是刚刚支付的订单呢？\n这里，我们可以再详细思考一下，其实这个订单不仅仅是由这个金额确定的，而是一个多元组共同确定的。最简单的一种实现方式就是 （订单金额-支付状态）。通过这个二元组可以确定一个订单。其含义是，如果这个订单已经支付过了，那么我在查找订单的时候，就可以不用理会它了，我只需要查找**（指定金额-未支付）**的订单就可以了。\n这样可以基本解决这个问题。但是，我们考虑到除了正常支付外，还有可能会有另外一些情况。比如用户创建了订单之后，突然不想支付了，没有进行接下来的操作。或者说，有人恶意在网站上创建了大量的订单并且不支付。 这样的后果是，这些订单的状态永远都是未支付，当你想要继续创建订单的时候，就会受到限制，不能创建跟这些订单相同金额的订单，否则你的系统将无法分辨到底是哪一笔订单被支付了。\n为了应对这种情况，我们想到其实很多的支付都是有时间限制的，也就是说，订单是有有效期的，一旦过了有效期，订单就不能被支付了。所以我们也可以给订单加一个有效时间的限制，比如5分钟，一旦五分钟内没有被支付，就认为这个订单已经失效了。这时，订单的确定方式就变成了一个三元组**（订单金额-支付状态-是否过期）**。查找的时候，只需要查找**（指定金额-未支付-未过期）**的订单就可以了。也就是说，任意一个订单，最多只会占用这个金额5分钟，一旦超过五分钟，不管支付与否，你都可以继续创建相同金额的订单了。\n但是这样我们还是觉得不满意，特别是对于某些支付金额相对单一的情况，可能每次都需要创建相同金额的订单，这样的话，再最坏情况下我们只能每隔五分钟处理一个订单，这个效率可以说是非常低效了。\n在这里，我们提出了一种trade-off的解决方法。一般的正常支付是不会使用这种方式的，也难以接受，但是对于我们来说，为了避免企业资质的认证和手续费，在一定程度上是可以接受的。\n这种方式就是，当目前系统中已经有了某一金额的订单的时候，如果我们要继续创建相同金额的订单，那么我们就在指定金额上进行上下浮动，比如下浮一分钱，这样金额就可以和之前的订单区分开来，避免出现不能同时支付的情况。这样，虽然我们在高并发情况下可能会有一定的损失（同时支付的人越多，差距越大），但是满足了我们的高并发要求。\n友情提示：如果金额发生浮动，可以告诉用户这是随机立减，一定程度上可以避免定价和实际支付金额的差距带来的问题。（这种情况下就只能下浮，不能上浮，不然就变成随机立加了）。\n三、总结 总体上来说，我认为这种方案对于普通的个人用户来说，是一种可以接受的方案。其优缺点总结如下：\n优点：  不需要企业资质 没有手续费 不对支付宝进行任何操作，没有被支付宝进行风控的风险  缺点：  需要有一部手机一直运行，且要求网络条件良好，否则会丢失支付数据（可以有人工解决方案） 高并发时，订单金额会产生浮动 如果金额浮动策略不合理，并且被人探索出规律，可能造成财产损失！！（例如短时间内创建大量订单，这样订单价格会不断下降，需要针对这种情况做出防范）  参考： PaysApi: https://www.paysapi.com\n","date":"2018-03-11T00:00:00Z","permalink":"https://jiacs.com/p/thinking-on-personal-pay/","title":"微信、支付宝个人收款的一种实现思路"},{"content":"最近看完了《编码》这本书，大呼过瘾。第一次看这本书的时候，一晚上就看了100多页，难以自拔（当然也是因为前面大部分都是作者放慢速度在引导，以及本身已经拥有了计算机的基础知识）。\n  编码.png \n这本书的书名是编码，但是书里实际讲述的不是狭义的ASCII、Unicode之类的字符编码，这其实是一本讲述计算机的底层工作原理的书。作为一个计算机专业的学生，虽然学过了数电和计算机组成原理，但是其实心里对于计算机的底层原理有很多疑惑，如果让我讲一下怎么从逻辑门构建起一个最初级的计算机系统，恐怕我说不出几句来。\n本书的作者Charles Petzold确实是个好人，在写了厚厚的《Windows程序设计》之后，还惦记着我们这些初学者，用生动简洁的语言，为我们编写了这本趣味版的数字电子电路，帮我们理解计算机的基本运行原理。\n这本书的内容，除了对于二级制、字节、十六进制、ASCII编码、定点浮点数之类的理论之外，基本上就是从零开始，用灯泡、导线、继电器，经过巧妙的组装，构建出一台电子计算机。听起来很令人诧异，但这就是人类计算机发展的历程。作者带着我们重新从头回顾了这段历史，让我们一方面惊叹于前人的智慧，能够从如此简单的部件开始，一点一点构建出更为复杂的组件，最终组成一台电子计算机；另一方面，作者在叙述过程中的由浅入深、抽象泛化能力也让人惊叹，在叙述的过程中不断将已经讨论过的部件抽象出来，让我们在思考的过程中能够不囿于繁杂的连线。或许计算机的发展就是在这样不断的抽象当中进行的，不断抽象屏蔽底层的细节，让我们在思考上层的结构的时候能够专注问题，无论硬件软件，皆是如此！\n本书的精华部分在第17章，这是真正把前面提到的各种元件组织起来，让他们按照我们的要求组织成一台电子计算机的核心部分。从运算器和存储器的组织，代码存储和数据存储的分离与统一，指令的设计与实现，都在这一章中淋漓尽致地展现了出来。这是真正烧脑又让人酣畅淋漓的一章。\n我认为，对于像我一样已经学过数电、计组等内容的人来说，这本书可以看做一种回顾和升华，将我们之前学过的内容串在了一起，并且弥补了之前学习过程中的某些断层，让我们对于计算机的运行原理有了更加完整且通畅的理解；对于那些计算机的初学者，甚至是没有学习过计算机的读者来说，这本书可以说是一本非常好的数字电路和计算机组成原理的入门书籍了，相对于国内教材的晦涩刻板，这本书能够引起兴趣，甚至让人有马上放下书动手一试的冲动。\n总之，如果你对神奇的计算机世界充满兴趣，如果你厌恶各式各样Boring充满说教和格式化的计算机教科书。那么你可以开始读这本书了，尽管IT技术日新月异，但是这本经典不会过时。\n","date":"2018-02-20T00:00:00Z","permalink":"https://jiacs.com/p/coding-book/","title":"荐书：《编码：隐匿在计算机软硬件背后的语言》"},{"content":"搞网络的对于 Wireshark 这个抓包工具应该非常熟悉了，在抓包分析的时候非常好用，很大的一个原因就是 Wireshark 内置了大量的协议解析插件，基本上你叫得上来的协议，Wireshark都能给你解析出来。\n但是啥事儿都有个万一，特别是像我们这种搞网络协议开发、修改的，经常就会遇到各种奇葩的网络协议，或者是自己拍脑瓜设计出来的网络协议，在调试的时候Wireshark不能正确解析，一个字节一个字节对着查那可真是看得眼都要瞎了。\n最近就遇上这么一个协议，其实也算不上协议，就是 Ethernet in UDP的封装：因为某些特殊的原因，需要将某个网口接收到的以太网数据帧，全部打包到UDP当中，作为UDP的PayLoad去解析。比较麻烦的就是，还非要把UDP PayLoad的前两个字节设置成自己的两个特殊字段，从第三个字段开始才是以太网数据帧。\n因为要开发相应的程序，需要反复调试对比，所以肯定就得动用Wireshark去分析，但是Wireshark又默认不支持这样的协议，所以对比起来很麻烦。网上查了一下相关的资料，发现可以用C去写插件，然后编译成链接库给Wireshark用，但是尝试了一会儿之后，发现实在是太麻烦了，编译环境搞了半天都搞不定。遂弃之，研究使用Lua脚本语言进行解析。\n0x01 基础知识 Lua是一种轻量级的脚本语言，解释执行，不需要编译器之类的。 Lua的基本语法可以参考 官网 或者 菜鸟教程。 Wireshark内置了对Lua脚本的支持，可以直接编写Lua脚本，无需配置额外的环境，使用起来还是非常方便的。 [Wireshark Developer\u0026rsquo;s Guide]里的第10章和第11章都是关于Lua支持的文档，有需要的话可以详细查阅。\n使用Lua编写Wireshark协议解析插件，有几个比较重要的概念:\n Dissector，中文直译是解剖器，就是用来解析包的类，我们最终要编写的，也是一个Dissector。 DissectorTable，解析器表是Wireshark中解析器的组织形式，是某一种协议的子解析器的一个列表，其作用是把所有的解析器组织成一种树状结构，便于Wireshark在解析包的时候自动选择对应的解析器。例如TCP协议的子解析器 http, smtp, sip等都被加在了\u0026quot;tcp.port\u0026quot;这个解析器表中，可以根据抓到的包的不同的tcp端口号，自动选择对应的解析器。  0x02 一个例子 我们先来看一下上面说的那个封装格式的脚本例子：（--后面的是注释）\ndo --协议名称为DT，在Packet Details窗格显示为Nselab.Zachary DT local p_DT = Proto(\u0026#34;DT\u0026#34;,\u0026#34;Nselab.Zachary DT\u0026#34;) --协议的各个字段 local f_identifier = ProtoField.uint8(\u0026#34;DT.identifier\u0026#34;,\u0026#34;Identifier\u0026#34;, base.HEX) --这里的base是显示的时候的进制，详细可参考https://www.wireshark.org/docs/wsdg_html_chunked/lua_module_Proto.html#lua_class_ProtoField local f_speed = ProtoField.uint8(\u0026#34;DT.speed\u0026#34;, \u0026#34;Speed\u0026#34;, base.HEX) --这里把DT协议的全部字段都加到p_DT这个变量的fields字段里 p_DT.fields = {f_identifier, f_speed} --这里是获取data这个解析器 local data_dis = Dissector.get(\u0026#34;data\u0026#34;) local function DT_dissector(buf,pkt,root) local buf_len = buf:len(); --先检查报文长度，太短的不是我的协议 if buf_len \u0026lt; 16 then return false end --验证一下identifier这个字段是不是0x12,如果不是的话，认为不是我要解析的packet local v_identifier = buf(0, 1) if (v_identifier:uint() ~= 0x12) then return false end --取出其他字段的值 local v_speed = buf(1, 1) --现在知道是我的协议了，放心大胆添加Packet Details local t = root:add(p_DT,buf) --在Packet List窗格的Protocol列可以展示出协议的名称 pkt.cols.protocol = \u0026#34;DT\u0026#34; --这里是把对应的字段的值填写正确，只有t:add过的才会显示在Packet Details信息里. 所以在之前定义fields的时候要把所有可能出现的都写上，但是实际解析的时候，如果某些字段没出现，就不要在这里add t:add(f_identifier,v_identifier) t:add(f_speed,v_speed) return true end --这段代码是目的Packet符合条件时，被Wireshark自动调用的，是p_DT的成员方法 function p_DT.dissector(buf,pkt,root) if DT_dissector(buf,pkt,root) then --valid DT diagram else --data这个dissector几乎是必不可少的；当发现不是我的协议时，就应该调用data data_dis:call(buf,pkt,root) end end local udp_encap_table = DissectorTable.get(\u0026#34;udp.port\u0026#34;) --因为我们的DT协议的接受端口肯定是50002，所以这里只需要添加到\u0026#34;udp.port\u0026#34;这个DissectorTable里，并且指定值为50002即可。 udp_encap_table:add(50002, p_DT) end 将其保存为 packet-dt.lua 文件 上面这段代码已经看起来非常清楚了，如果是解析一般的自定义协议，上边的代码基本上够用了。\n0x03 Lua插件的启用 想要启用Lua插件，首先要确认你的Wireshark版本是支持Lua的（Windows版本默认应该都是启用支持了的）。可以通过【帮助】-【关于】窗口确认：   lua支持.png \n如果是这种With Lua的，应该就是可以的了。\n然后去文件夹选项卡，找到Global Configuration文件夹的位置:\n  global-configuration.png \n在这个文件夹里找到init.lua文件，使用文本文件编辑器打开它，在文件的最后添加：\ndofile(\u0026quot;c:\\\\path\\\\to\\\\packet-dt.lua\u0026quot;) 填写好正确的packet-dt.lua所在的位置，保存文件就可以了。 然后重新启动Wireshark或者点击【分析】-【重新载入Lua插件】，就可以启用你自己的lua插件了。\n0x04 测试与调试 测试的话，直接抓包就可以看到对应的包的协议列变成了DT，并且Packet详情窗口里可以看到对应的协议行了。 如果出现问题，Wireshark会直接在对应位置报错，按照报错信息修改packet-dt.lua文件，保存后重新载入Lua插件就可以。\n0x05 高级一点的玩法 虽然我们实现了基本的包解析功能，但是其实我之前说过，我们的UDP的PayLoad里封装的其实是以太网包，能不能让Wireshark在我们的插件执行完之后，继续按照以太网格式解析其他部分呢？肯定是可以的。\n这里，我们只需要重新构造一下需要继续解析的数据，然后获取出一个以太网解析器就可以继续做下去了：\nlocal raw_data = buf(2, buf:len() - 2) Dissector.get(\u0026#34;eth_maybefcs\u0026#34;):call(raw_data:tvb(), pkt, root) 把这段添加在刚才的 t:add(f_speed, v_speed)之后，就可以了。 这里要注意两点，第一点是获取的解析器名称应该是 eth_maybefcs，这个坑了我很久，因为DissectorTable里写的也是eth，但是提示找不到。网上查了很久之后才发现应该用这个名字去获取，意思是可能带有fcs的eth帧。。。\n第二点是raw_data需要调用一下tvb()函数，不然会提示你这个是userdata，不能使用。tvb的全称应该是Testy Virtual Buffer，用来存储Packet buffer的，要处理必须先转成这个。\n这样你测试的时候，就可以看到，Packet Details窗口里的\u0026quot;Nselab.Zachary DT\u0026quot;栏的下面，又出现了Ethernet、IP等，这就是内部的数据解析出来的结果。\n当然，你也会发现列表的协议栏又被改成了ARP、ICMP等内部协议的名称了，这是因为调用eth_maybefcs解析器的时候，这些解析器又会给协议栏赋值，覆盖掉我们之前写的DT。为了和其他的区分，我们还可以玩得更骚气一点，在上面的代码之后加上：\n pkt.cols.protocol:append(\u0026quot;-DT\u0026quot;) 这句话的意思就是不管协议栏被改成了啥，我都在后面加上-DT，这样ARP、ICMP等就会变成 ARP-DT、ICMP-DT了，一眼就可以跟那些平淡无奇的ARP和ICMP区分出来。\n0x06 结束语 总的来说，使用Lua来编写Wireshark的协议解析插件还是比较简单的，相对于使用C语言，配置、开发、调试应该都方便了不少。当然，如果要详细开发，肯定还是要多看看官方的开发文档：Wireshark Developer\u0026rsquo;s Guide.\n","date":"2018-02-01T00:00:00Z","permalink":"https://jiacs.com/p/wireshark-plugin-using-lua/","title":"自己动手编写Wireshark Lua插件解析自定义协议"},{"content":"最近实验室要使用OPNET做仿真，但是无奈18.6在windows下的sitl接口一直有问题，没办法，只能尝试一下linux下的版本是否可以用。但是以前从来没在linux下装过OPNET，所以还是踩了一些坑，总结一下主要的安装步骤。\n0x00 安装环境 系统版本： Ubuntu 16.04 TLS Desktop （最新的版本可能要考虑一下gcc的版本问题，OPNET要求的gcc版本是4，但是好像16.04默认安装的版本也是可以的） OPNET版本：18.6.1 build 20050\n0x01 准备安装文件 linux下的OPNET安装文件是一个bin文件（modeler_1861_20050_linux86.bin），准备好放到系统里就行。\n0x02 权限说明 因为我要使用sitl接口，所以整个的安装、运行全都是在root用户里进行的。如果不需要sitl接口，安装可以使用root用户，运行可以直接用普通用户。\n0x03 安装步骤：  启用root用户的图形界面权限  打开终端，在普通用户权限下运行\nxhost + 给安装程序赋予执行权限  进入到安装程序所在目录，执行\nsudo chmod a+x modeler_1861_20050_linux86.bin 使用root用户，启动安装程序  sudo su ./modeler_1861_20050_linux86.bin 然后应该可以看到图形界面，根据你的需要选择就可以，我这里全部下一步到安装完成。\n添加启动路径到PATH环境变量中  默认情况下，安装在/usr/riverbed文件夹中，可执行文件都在/usr/riverbed/18.6/sys/unix/bin目录下。 所以我们把这个路径添加到PATH变量中：\nexport PATH=$PATH:/usr/riverbed/18.6/sys/unix/bin 为了以后可以直接启动，也可以把这条命令添加到你的终端rc文件中，例如~/.bashrc或者~/.zshrc等\n安装csh  OPNET的启动依赖于csh，所以通过下面命令安装\nsudo apt install csh 启动测试  到这里安装就完成了，直接在终端执行\nmodeler 就可以启动OPNET了。\n0x04 编译环境的配置 我这里默认已经装好了gcc和g++，也不需要配置其他环境变量，可以直接编译。如果系统里没有装的话，可以用下面命令安装\nsudo apt install gcc g++ 0x05 附赠添加启动快捷方式的步骤 (针对非root用户运行的情况) sudo vim /usr/share/application/modeler.desktop 然后再打开的这个空文件里，按i进入insert模式，输入以下内容\n[Desktop Entry] Encoding=UTF-8 Name=RiverBed Modeler 18.6 Comment=riverbed modeler Exec=/usr/riverbed/18.6/sys/unix/bin/modeler Terminal=false Type=Application Categories=Application;Development; 按ESC退出insert模式，输入 :wq 保存退出即可。\n这样在系统应用程序里，就可以看到这个程序了。\n0x06 Trouble Shooting 我这里在编译链接的过程中，出现了下面的链接问题：\n/usr/riverbed/18.6/sys/pc_intel_linux64/lib/libz.so.1: no version information available 初步判断是opnet自带的zlib的版本问题，所以我选择自己通过系统安装zlib1g，然后替换这个文件。步骤如下：\nsudo apt install zlib1g cd /usr/riverbed/18.6/sys/pc_intel_linux64/lib/ sudo mv libz.so.1 libz.so.1.backup 然后重新运行DES应该就可以了。\n0x07 总结 以上就是在Ubuntu 16.04 上安装OPENT 18.6的过程，相对来说比windows上安装多需要一些经验，但是配置环境变量之类的情况要少很多。\n","date":"2018-01-16T00:00:00Z","permalink":"https://jiacs.com/p/linux-opnet-installation-guide/","title":"Linux下安装Riverbed OPNET Modeler 18.6.1过程"},{"content":"嗯，一眨眼2017年又过完了，第三年写年终总结了，从大二开始每年都写写年终，回头想想自己都干了点啥，但是每年立下的豪言壮语好像也并没有怎么实现过= = 不过总归是一种记录吧，毕竟我脑子也不好使，希望以后看到的时候能够记得自己都干过了啥。\n2017年，上了研究生，决定了读博，结束了单身，emmmm大概其实也就这么多，按时间整理一下流水账吧。\n0x00 “老大爷”生活 过完年回来，就一头扎进了实验室，开始了遛弯看新闻写论文的“老大爷”生活，那段时间其实还是非常轻松的，虽然同时做着实验室的项目、自己的毕设还有写论文，但是其实没有了课程上面的纠缠，每天只是单纯地谢谢代码看看新闻，可以有时间做自己感兴趣的事情，仿佛就是理想的研究生生活。\n然后5、6月份，虽然写论文的时候纠结了很多，但是不管是查重、答辩都是非常顺利地完成了，作为非优秀毕业生的我，最后就像看着别人毕业一样，看着自己毕业了。\n终于结束了四年的本科生活，这四年，成长也好，颓废也好，总体看来，还算得上没有虚度，还是学习了很多自己上大学以前想的东西，也没有挂过科，带了社团，参加了实习，虽然后两年的时间，总感觉自己进入了瓶颈期，但是不管怎样还是给自己的本科四年结了一个不是那么糟糕的结尾。\n我是一个感情没那么容易表露出来的人，或许也是一个感情冷淡的人？当然也跟我还得在这呆好多年有关，反正就像以前的所有毕业一样，没有更多的留恋，没有什么忧伤，就这么淡淡地结束了本科的生活。\n0x01 研究生的新生活 忙碌而焦头烂额，可以说是研究生第一个学期生活的真实写照了。\n作为一个本来就焦虑感极强的人，研究生上来的两门数学课，直接就将我的焦虑感拉上了顶峰。甚至在第一个周就想退掉最优化了= = 再加上第一年的课程改革，林老板非常明确的表达了要累死我们的目标。。总之研究生生活仿佛每天都在作业、Presentation、“又要上课”的抱怨中度过。虽然没有本科的时候的课程那么多，但是作为研究生，还有更多其他的事情要做，不像刚刚上大一的时候，静下心来学习就行，对于ADHD晚期患者来说，简直是灾难一般的存在。\n一个学期下来，考试结束了，成绩还不知道，不知道会不会破纪录。还有就是研究生期间真的是和其他实验室的人接触太少，一个学期下来自己班的人都认不全，随它去吧……\n0x02 我要读博 2017年还做了一个重要的决定就是读博，可能比我以前的所有决定都更加重要吧，这个决定直接改变了我原来划定好的人生轨迹，将自己的人生引入了另一个好像从来没想过的方向。从十几岁开始，我的目标好像就是当一个程序员了，以前所做的决定，一点一滴，都是慢慢向这个方向靠近的，也许有不断的修正，但是大方向从来没有改变过。如今几乎是从头开始，要重新考虑自己未来的规划和人生，也算是“拥抱变化”了。\n读博的根本原因，我想，也许还是出去实习的那段时间吧。在灵析这样的小团队和百度这样的大公司都呆过之后，我慢慢地发现自己好像真的有点不太适应这种朝九晚九的螺丝钉生活，每天都在重复着前一天的自己，工作就是CURD boy。 我当然明白作为一个实习生，也不可能做多少更加creative的工作，但是想要做更多的工作，几乎都要经历这样一个过程，越大的公司越如此。 我不知道自己能否就这样忍受完这样的一段经历，也不知道这样经历完的我，最后会变成什么样。\n反正在孙老板的“利诱”下，最后还是选择了硕博连读。硕博连读也是妥协的决定，如果我在当年保研之前就做好了这样的决定，那我更倾向于直接去国外读博的，毕竟外来的和尚好念经，出去过的回来也有更好的发展。但是已经在交大读了硕士，如果读完这3年，再出去读5年，外加3年的博后，那就是11年了。不管是从政策的变化，还是家里的情况，似乎都不是那么得现实。最后还是选择了硕博连读，5年搞定所有，当然也可能是6年。。。。\n当我看到了UTS的双博士学位的时候，好像才最后下定了决心，仿佛发现了拯救自己的办法。五年的时间，出去两年，也许会很辛苦，但是能拿到两个博士学位，那也可以说是非常超值了。\n不管怎样，已经决定了，只要不挂科，明年就开始自己的博士生涯了。\n0x04 2018 2018就这么悄悄地来了，我好像还没有怎么意识到，第一个月就已经过去三分之一了。\n2018还是要给自己立下很多flag，万一实现了呢？比如读书、比如锻炼、比如论文、比如博客。路还是要一步一步走，总之慢慢朝向那个自己喜欢的方向去。\n2018，我，\n一起加油吧！\n","date":"2018-01-09T00:00:00Z","permalink":"https://jiacs.com/p/2017-conclusion/","title":"2017年终总结"},{"content":"最近给实验室的Gitlab服务器开启了CI功能，采用的是docker模式，每次都启动一个全新的镜像进行构建。\n为了对Python代码进行风格检查，每次在构建的时候，都需要先在启动的容器中使用pip安装flake8。由于每次构建之间的环境相互隔离，所以pip的缓存也就完全没有作用，每次都需要直接联网下载相关的包来安装。\n国内的网络大家都懂，下载新包的速度时好时坏，严重影响了构建的速度。在配置CI的时候，正好看到了有cache的选项，遂决定启用cache，不必每次都从网络下载。\n首先根据网上查阅的资料，在.gitlab-ci.yml中配置如下：\nimage: python:3.6 cache: paths: - pip-cache key: $CI_PROJECT_ID # This is a basic example for a gem or script which doesn't use # services such as redis or postgres before_script: - python -V # Print out python version for debugging - export PIP_CACHE_DIR=\u0026quot;pip-cache\u0026quot; - mkdir -p pip-cache - ls pip-cache - pip install flake8 lint: script: - flake8 . 其中重点是cache部分，该部分paths置顶了要缓存的目录，key指定了缓存的key（即只有key匹配时，才会启用缓存）。\n在这里，我使用了当前目录下的pip-cache目录作为pip的缓存目录，项目id作为key，也就是本项目的所有构建都会共享这个目录。\n另一个重点是export PIP_CACHE_DIR=\u0026quot;pip-cache\u0026quot;这条命令。这条命令设置了一个PIP_CACHE_DIR的环境变量，pip会根据这个环境变量，将缓存放在我们指定的pip-cache目录下。\n配置完成后，启动pipeline运行，发现还是每次都会从网络上下载Python的包。\n经过多次搜索后发现，还需要对gitlab-ci-multi-runner进行配置。\n我是根据系统帮助，直接在Ubuntu仓库里安装的，因此配置文件在/etc/gitlab-runner/config.toml当中。\n打开该文件，可以看到[runners.docker]部分中的volumes = [\u0026quot;/cache\u0026quot;]这一条配置。根据我们对docker的了解，如果要进行持久化，需要将外部的一个目录挂载到容器内部，但是这里明显没有指定外部的目录。\n修改这一行为：\nvolumes = [\u0026quot;/root/build_cache:/cache:rw\u0026quot;] 也就是把外部的/root/build_cache目录挂载到容器中的/cache目录中，并且给予读写权限。这样gitlab-runner每次创建缓存的时候，都会在/cache中(默认配置，可以按照官网文档修改)，也就是存到了宿主机的/root/build_cache目录中。当启动一个新的容器的时候，也会从宿主机的/root/build_cache中加载缓存文件。\n最后，重新启动pipeline，发现pip已经可以成功使用缓存安装需要的包了。\n","date":"2017-04-06T00:00:00Z","permalink":"https://jiacs.com/p/gitlab-ci-pip-cache/","title":"gitlab-ci中pip缓存的配置"},{"content":"拖了好久，终于把《刻意练习》这本书看完了。\n作者说了好多，提到了好多的案例，最主要的还是为了证明自己的观点：“刻意”的练习才是最重要的。也就是说相对于练习的时间，练习的效果更加重要。\n刻意练习，其最根本的还是找到正确的练习方法，然后不断积累，经过一定的时间之后，就会发现练习的效果。也就是：积小胜为大胜，积跬步以至千里，最终达到长期目标。\n作者提出的与其他的鸡汤最主要的区别就是：在练习的过程中，要进行有目的的练习。主要有以下几点：\n  定义明确的目标 与其他的目标管理方法一致，刻意练习也强调有一个具体而明确的目标。目标可以有效地引导你的练习。在实施的过程中，要学会把目标分解，一步一步完成大目标。并且，你还需要为这个大目标制定一个计划来保证它的实施。\n  走出舒适区 如果你每次都练习同样的内容（特别是在你的舒适区内的内容），那么无论重复多少次，最终你的成长几乎是微乎其微的。只有走出舒适区，走到那些你努力一下，跳一跳才能够得到的地方，经过努力并且完成了它，才是真正能够提供能力的练习。\n  必须有合适且及时的反馈 反馈是非常重要的，有了及时且正确的反馈，才能在练习中及时了解自己的情况，进而找到办法去练习它、修复它。刻意练习非常重要的一点是要能够找到衡量的标准，并且能够对照这个标准来获得反馈。\n ","date":"2017-02-12T00:00:00Z","permalink":"https://jiacs.com/p/keyilianxi/","title":"关注练习的效果——《刻意练习》读后感"},{"content":"一年又一年啊= =\n过得好快，一眨眼2016又要过去了。\n是时候总结一下我的2016年了，总得来说感觉今年还算是收获的一年吧，毕竟结束了大三下学期，成为大四的学生了。同时今年也又经历了一次重大的人生抉择。\n按时间整理吧， 首先就是今年年初就开始筹划自己的暑期实习了，投了不少简历，也参加了好几次的笔试以及面试，甚至还参加了百度和腾讯的实习生面试。不过最终是只拿到了灵析的Offer，当然也是当时拿到灵析的Offer之后，已经决定去灵析了就没有继续再找了。\n然后就是大三下的学习成绩，可以说算是非常的高了，虽然有四门课没有拿到满绩，但是已经是相当不错的成绩了。让我成为了大三学年的年级第二，也成功得把总绩点拉到了4.07，让我能够保研。大三下对于我来说学习上应该算是相对轻松的一年，虽然好几门的“硬课”，平时作业啥的也很多，但是毕竟都是专业课，让我能够相对轻松地去听课学习。\n接着7月份开始到灵析实习了，这算是我第一份真正的工作了。虽然之前有极客学院的经历，但那毕竟只是兼职。而在灵析的实习，我是真正开始了每天地铁上下班的生活。在灵析我开始真正接触真正需要上线的业务代码，开始编写一旦出现bug就会造成真金白银损失（不过我好像没有造成过这样的损失吧……）的支付业务代码。当然在灵析也对PHP和Laravel有了更深的理解。虽然在灵析只呆了3个月，但是成长算是很大的。\n然后就是人生中的又一个重大决定了。这是自中考择校，高考择校之后，我的又一次自主择校经历。假期用一个周的时间参加了中科院信工所的夏令营，在夏令营中遇到了刘偲老师，本来已经基本决定了要去她那的。但是最后一方面考虑到那边的压力，以及我自己对新环境的适应恐惧，我最后还是决定留在了交大。\n回想当年，中考择校的时候，最终让我做出决定的，是一句“有好的凭什么不去，难道不划片招生我还不去一中了？”，最后坚定而决绝。并且从未后悔过自己去一中的选择。\n高考择校的时候，让我作出决定的是“我一定要上计算机专业，就算学校差一点，也要保证在计算机专业”。最终我来到了交大，来之前没有后悔过，来之后，确实有好几次觉得自己是不是当年选的不够好。\n而现在，让我做出决定的竟然是压力和累不累。真是越活越苟且了。并且，还没有开始上学，就开始思考自己做出的选择是否正确了。\n人在成长，思考的东西也越来越不同。到底是成长了还是失去锐气了，说不好。\n10月份从灵析离开之后，我回了一趟家。经历了人生第一段彻底的迷茫期，之前从未遇到过的迷茫期。我用这样的一段话来描述当时的状态：“在高考的时候，山就在远方，路就在脚下，但是路上有无数的荆棘和泥泞，我要不断地往前爬，才能不断地接近山；而现在，我的眼前是一片漆黑，我看不到山在哪，也不知道路在哪，像一个瞎子被扔在了一个完全陌生的地方，不知道该干什么，也不知道目标在哪里”。\n后来，机缘巧合，我又以一种异常轻松的方式拿到了百度的实习Offer，遂决定去百度。刚进百度，也是对新环境的恐惧和没有实际的工作，也还是在迷迷瞪瞪之中。一直到前几个周，才开始真正进入工作状态。\n在灵析和百度的这两段并不十分长的实习经历，让我又重新开始思考未来。我真的就想这么做一个写业务逻辑的码农吗？目前来看并不是的，我反而更喜欢实验室正在进行的各种科研方面的东西。创造新的东西让我感到一种久违的兴奋，也许在研究生的3年，会是我继续寻找自己的目标的3年。\n还有就是前段时间又参加了一次科技之星，然而继续陪跑Orz、、、\n另外就是开始参与实验室的一些工作，当然更让我兴奋的其实是终于有机会在实验室搭建内部的Gitlab服务器、Wiki服务器以及持续集成服务器，不知道为什么自己对这些东西非常感兴趣。\n回首2016，也算是有不少的收获和成长，学习、保研、实习，各项穿插而又有序地进行，经历了迷茫，开始了思考。也许我还没有到最后下定决定的那个时刻。\n2017，就这么不声不响地来了，好快，不敢想象一眨眼自己已经马上要23岁了。\n2017，读书，运动，科研，兴趣。期待新的自己。\n","date":"2016-12-19T00:00:00Z","permalink":"https://jiacs.com/p/2016-conclusion/","title":"2016年总结——又一年"},{"content":"刚创建了一个新的Laravel 5.3项目，想要使用Laravel自带的认证功能。\n但是我们都知道，Laravel默认情况下的Model都是放在app目录下的，也就是说其命名空间是App.但是有时候我们希望app目录能够更加整洁一点，所以想要把各个Model都统一放在Model目录下。 由于Laravel的app目录遵循了psr-4标准，也就是说会是用composer按照psr-4标准对各个类进行自动加载。如果我们直接修改目录，而不修改对应的命名空间的话，是无法正常加载这些Model类的。\n所以，将User.php文件移动到了新的Model文件夹下的时候，需要同时将User类的namespace修改为App\\Model。然后，需要执行\ncomposer dumpautoload 命令，将修改后的类自动加载进来。\n接着继续进行认证系统的创建。\n在执行了\nphp artisan make:auth 命令之后，在正常情况下，已经可以实现正常的注册、登录等功能了。\n但是在修改完User的命名空间后，会发现出现了找不到User类的错误。我们刚才已经重新加载了User类，为什么还会出现找不到的问题？\n仔细想想我们就会发现，由于登录、注册用到的代码都是Laravel框架自带的，默认情况下，它们会认为User类还在App命名空间下，所以登录的时候，会出现错误。\n如何解决呢？\n在config/auth.php文件里，可以找到providers，在其中driver是eloquent的那一组中，可以看到model选项，默认为App\\User::class，将其修改为App\\Model\\User::class即可。\n这样应该就可以正常登录了。\n所以总结一下，如果想要修改User的命名空间的话，需要以下几步：\n 新建Model文件夹，移动User.php到该文件夹下 修改User.php的namespace为App\\Model 执行composer dumpautoload，重新加载类 将config/auth.php文件中的providers部分的model对应的类，修改为App\\Model\\User::class ","date":"2016-09-19T00:00:00Z","permalink":"https://jiacs.com/p/laravel-user-namespace/","title":"修改Laravel自带的认证系统的User类的命名空间"},{"content":"转眼间，在灵析实习已经一个多月了。中间请了一个周的假参加夏令营，算起来总共待在灵析的时间也已经有5个周了。\n那么在这五个周里，我到底学到了什么呢？\n工具篇： 作为一个工具控，当然要先说一下在灵析学到的各种新的工具啦。\n  团队沟通 Slack\nslack确实是一个非常优秀的团队沟通工具，可以非常简单地发起群聊，单聊等。不过其在国内的访问速度略慢，所以我自己在选择的时候，选择了国内的同类产品BearyChat，速度相对快不少。\n  任务（项目）管理 Worktile\n我们团队使用Worktile来进行任务管理。特别是对于开发来说，Worktile是一个非常好的与其他部门进行合作的工具。我们的运营客服经常会收到用户反应的各种bug，这些都会直接记录到Worktile上，然后由技术部的负责人将这些bug或者feature在Worktile上直接分配给对应的程序员，非常方便。特别是Worktile的拖拽的操作方式，非常直观。\n  代码管理 SourceTree\n以前对于SourceTree只是听说，基本上没有用过。团队里的其他同学用的都是SourceTree，所以我也使用了它，感觉上非常的便捷，很多操作都可以不用CLI来进行了，对于多个仓库的支持也很好。缺点是长时间使用（像我这种每天不关机的人……）会变卡，需要重启一下。\n  工作流 灵析研发的基本工作流我觉得非常棒，刚来的时候让我有一种置身大公司的规范感。（虽然后来发现这个流程其实并不是特别严格地被遵守……）\n研发这边的基本工作流，就是对于现有的系统，如果要进行bug修复或者feature添加，一共有以下几个步骤：\n 开发人员拉一个新的feature分支出来 在该分支上进行自己的开发 开发完成后，将代码push到gitlab上，然后创建MergeRequest 技术负责人对代码进行Review，提出对应的修改建议 开发人员继续修改 修改完成后由技术负责人将代码合并回开发分支  我觉得这种开发的流程，能够非常好地保证代码的质量，同时开发流程也相对清楚明了。\n当然，也有一定的缺陷，比如代码的Review都由技术负责人进行的话，在团队规模扩大后可能会出现问题，这个可以由比较有经验的程序员进行Review或者互相Review。\n技术相关 首先最明显的肯定是对于PHP和Laravel框架的了解啦，虽然现在还是处于查着文档写代码程度，但是对于整个Laravel框架的理解更加深入了一层，比起自己当时只会页面和Controller的程度要好了不少。特别是进行灵析支付这部分的开发工作，让我开始了解到了使用Laravel时候需要进行的系统架构设计等工作。还有就是对Laravel中的IoC、DI、Facade等的了解，从原来的基本上没有概念，到现在能够理解并且运用，而且还和之前自己学习的Spring框架的相关内容对应了起来，让我觉得非常的受益。\n另外，对于单元测试（现在仅仅局限于PHPUnit），也有了相应的了解和经验，能够大体上编写对应的单元测试。以及对于CI，也正好和我之前看的一些东西结合了起来。这种感觉，就像刚在课本上学到了一个知识点，然后马上就用到了一样，特别爽！\n总结 总之，在灵析的这一个月，确实学到的很多东西。当然，每天上下班的一个小时也是醉……\n","date":"2016-08-13T00:00:00Z","permalink":"https://jiacs.com/p/first-month-at-lingxi/","title":"灵析的一个月总结"},{"content":"今天在调试Laravel时，发现Routes.php中定义的路由不起作用了！不管怎么修改，甚至删除，新修改的路由都不生效。\n使用命令行运行\nphp artisan route:list 查看路由时，也发现不管怎么修改都没有变动。\n在经过多次查找时候，突然想到了路由缓存。于是赶紧查了一下Laravel的路由缓存的用法及其设置。最后发现确实是由于Laravel中的路由缓存造成的问题。\nLaravel中的路由缓存是为了提高系统的运行效率，防止在大项目中每次都查询Routes.php文件查找路由列表。而路由缓存的使用方法也非常简单，一共就涉及以下两个命令：\n//创建及更新路由缓存 php artisan route:cache //清除路由缓存 php artisan route:clear 当要创建路由缓存时，就使用第一个命令，然后不管你再修改routes.php文件，都不会起作用。如果更新了routes.php文件中的路由，想要让其生效，那么再次执行以下第一条命令就可以了。\n如果想要不再使用路由缓存，则直接执行第二条命令即可。\n","date":"2016-07-05T00:00:00Z","permalink":"https://jiacs.com/p/laravel-routing-cache/","title":"laravel 路由缓存"},{"content":"本科阶段的期末考试生涯在昨天结束了。\n昨天考完操作系统之后，终于跟期末考试说再见了。其实也算是本科的学习阶段的结束了吧，剩下的时间，要去实习，要准备保研，要做毕设，反正不会再像之前一样上课写作业了。\n也算是一个新的开始了吧，从今天开始，不会再有课程分数的压力来逼着自己看书、复习，只能靠自己的自觉来不断提高自己，找到自己的方向。以后的路，靠自己的选择了。\n自勉之。\n2016年6月30日\n","date":"2016-06-30T00:00:00Z","permalink":"https://jiacs.com/p/final-of-bachalor-ends/","title":"本科的期末考试结束了"},{"content":"今天在给一台电脑配置XAMPP的时候，在上面的PHPMyAdmin里创建了一个新的用户，并且创建了密码，但是却一直无法使用这个账户登录到MySQL里。\n使用PHPMyAdmin的话，会提示登录失败。而直接在命令行登录的话，会提示ERROR 1045 (28000): Access denied for user 'laravel'@'localhost' (using password: YES)。如下图：\n按照网上说的解决方案，我尝试了使用root账户这个laravel账户进行授权，直接把all privileges授权给它，但是还是登录不成功。\n最后，经过多次尝试后，我终于发现了问题所在：MySQL中默认存在一个用户名为空的账户，只要在本地，可以不用输入账号密码即可登录到MySQL中。而因为这个账户的存在，导致了使用密码登录无法正确登录。\n解决方案： 只要通过root账户登录，然后将该账户删除即可：\nmysql -u root # 以root账户登录MySQL use mysql #选择mysql库 delete from user where User=''; #删除账号为空的行 flush privileges; #刷新权限 exit #退出mysql 现在，就可以使用刚才创建的账户和密码登录了：\n","date":"2016-05-17T00:00:00Z","permalink":"https://jiacs.com/p/mysql-user-user-cannot-login/","title":"解决MySQL新建用户后无法登录问题"},{"content":"前段时间看到有人给简书提供的建议里有一条是希望简书能够提供用户自定义子域名功能。作为一个攻城狮，自然就开始想到自己能够怎么实现这个功能，于是马上联想到了“泛域名解析”功能。再加上之前录制《Laravel 入门之路由》这门课程的时候，提到过的子域名路由这个功能，马上就想到了针对用户自定义域名的解决方案。\n首先呢，稍微解释一下泛域名解析，泛域名解析就是在添加域名的解析记录的时候，添加一条带通配符*的记录，这样就能够匹配到其他的所有域名。 比如，下图是DNSPod的域名解析服务，可以看到，它提示我如果使用*的话，就可以匹配其他所有域名。\n所以，我们就添加这样的一条记录。 这里因为我在内网调试，所以就直接把记录的内容填成了我的内网地址。大家在使用的时候记得填写服务器地址就行。\n等待一会儿之后，添加的记录就生效了。这时候，我只要随便输入一个之前不存在的子域名，都会指向192.168.1.101。比如：\n现在，我们只需要进入到Laravel当中去，修改一下路由。\n上图里，我给这个组添加了一个domain的限制，并且在它对应的值里添加了一个user的参数，也就是说它会将子域名部分当做参数，传递给组内的所有请求处理函数。 然后，在里面的这个请求处理函数里，我只是简单的显示了一下这个子域名。对于大家来说，可以通过这个参数，找到对应的用户，显示用户的个人主页，这样就是可以实现通过子域名访问用户的主页啦！\n当然，在这之前还要进行子域名和用户之间的绑定，不过这个就非常简单了，在数据库里添加一条记录就可以了。\n这样，通过泛域名解析和Laravel提供的的路由功能，就能非常简单的实现用户的自定义域名啦。\nPS：我这里只是进行了原理性的演示，实际使用过程中还需要对服务器软件（Apache、Nginx等）进行配置，让它们能够支持通过不同的域名来访问。\n","date":"2016-04-20T00:00:00Z","permalink":"https://jiacs.com/p/custom-subdomain-using-laravel/","title":"使用泛域名解析和Laravel路由实现用户自定义子域名"},{"content":"最近在操作系统上学习了Peterson算法，其使用了3个变量就实现了纯软件的线程同步，即两个线程的标记变量c1, c2以及一个turn变量。 但是对于其为什么要使用第三个变量还不是很了解，今天特意研究了一下，终于发现了第三个变量的作用。\n0x0 Peterson算法的实现 以下给出Peterson算法在windows下的一种简单实现：\nint c1 = 0, c2 = 0, will_wait; DWORD WINAPI p1(LPVOID p) { int counter = 0; int tmp1, tmp2, r; do{ //加锁 c1 = 1; will_wait = 1; while(c2 \u0026amp;\u0026amp; (will_wait == 1)); tmp1 = accnt1; tmp2 = accnt2; r = rand(); accnt1 = tmp1 + r; accnt2 = tmp2 - r; counter++; }while(accnt1 + accnt2 == 0 \u0026amp;\u0026amp; (c1 = 0) == 0); printf(\u0026quot;%d\\n\u0026quot;, counter); return 0; } DWORD WINAPI p2(LPVOID p) { int counter = 0; int tmp1, tmp2, r; do{ //加锁 c2 = 1; will_wait = 2; while(c1 \u0026amp;\u0026amp; (will_wait == 2)); tmp1 = accnt1; tmp2 = accnt2; r = rand(); accnt1 = tmp1 + r; accnt2 = tmp2 - r; counter++; }while(accnt1 + accnt2 == 0 \u0026amp;\u0026amp; (c2 = 0) == 0 ); printf(\u0026quot;%d\\n\u0026quot;, counter); return 0; } int main() { system(\u0026quot;pause\u0026quot;); HANDLE hFirst = CreateThread(NULL, 0, p1, NULL, 0, NULL); HANDLE hSecond = CreateThread(NULL, 0, p2, NULL, 0, NULL); WaitForSingleObject(hFirst, INFINITE); WaitForSingleObject(hSecond, INFINITE); system(\u0026quot;pause\u0026quot;); return 0; } 在该程序中，主程序开辟两个新的线程p1和p2，如果程序运行出现问题，则accnt1和accnt2的值相加不为0，则该线程退出。\n0x0 简单的情况 从最简单的情况思考，当线程1首先进入临界区(Critical section)时，其值设为1，而当线程2准备进入临界区时，会判断c1是否为1，若为1，则会进入循环等待。当线程1退出后，c1=0，线程2得以进入临界区。 通过这种方式，实现了两个线程之间的同步。\n那么，为什么还需要一个turn变量呢？\n0x1 另一种情况 要理解turn变量的作用，需要考虑另外一种情况。\n假设两个线程几乎同时加锁，则其在加锁时的代码可以认为是混杂执行的。c1,c2都被设为1，然后两个线程先后进入阻塞循环当中。此时，如果阻塞循环如下：\nwhile(c2); //p1进程 while(c1); //p2进程 则两个进程都会进入阻塞状态，互相阻塞，无法继续进行。\n0x2 引入turn（will_wait）变量 下面考虑存在turn变量的情况。 两个线程分别将c1,c2设为1，然后继续执行，都将turn设为自己对应的序号（1或2）。但是由于其执行顺序必然有先后，因此先赋值的会被覆盖掉，最终的值变为另一个线程的值。假设p1先执行\nwill_wait = 1; // p1 然后p2执行：\nwill_wait = 2; // p2 最终，will_wait变量的值将变为2。\n而当两个线程进入到阻塞循环当中去时，由于判断条件如下：\nwhile(c2 \u0026amp;\u0026amp; (will_wait == 1)); //p1 while(c1 \u0026amp;\u0026amp; (will_wait == 2)); //p2 对于线程1来说，不满足循环条件（will_wait不等于1），则程序会继续运行，进入临界区。 而对于线程2来说，满足阻塞循环的条件，会阻塞在该循环中，直到p1释放锁。\n0x3 实验验证 为了验证不使用turn变量时，程序会进入互相阻塞状态。可以将两个线程改为如下代码：\n//p1代码，p2类似 DWORD WINAPI p1(LPVOID p) { int counter = 0; int tmp1, tmp2, r; do{ //加锁 c1 = 1; while(c2); tmp1 = accnt1; tmp2 = accnt2; r = rand(); accnt1 = tmp1 + r; accnt2 = tmp2 - r; counter++; printf(\u0026quot;1: running\\n\u0026quot;); }while(accnt1 + accnt2 == 0 \u0026amp;\u0026amp; (c1 = 0) == 0); printf(\u0026quot;%d\\n\u0026quot;, counter); return 0; } 可以看出，如果程序能够正常进入临界区，则会不断循环输出1: running。 另外，需要注意的是，Peterson算法只能在单核系统下生效，如果要在多核系统下生效，需要进行以下操作。\n 首先在main函数的开始位置，添加一行system(\u0026quot;pause\u0026quot;); 运行程序，程序会等待用户按任意键继续运行。 在任务管理器中找到该程序，点右键（win10下需要转到详细信息页点右键），选择设置相关性，然后只选中一个CPU核心。 回到编写的程序，按任意键继续运行。  程序运行结果如下： 而添加will_wait变量之后，程序的运行结果如下： 可以看出，在没有加turn变量时，线程1执行了两次之后，就进入了相互阻塞状态，两个线程都不继续运行。而加了turn变量之后，程序则会持续运行下去，不断输出，同时也没有出现同步问题导致进程被终止的情况。\n0x4 由此证明，turn变量在Peterson算法中是为了保证程序不会出现相互阻塞而产生的，不可缺少。\n","date":"2016-04-10T00:00:00Z","permalink":"https://jiacs.com/p/peterson-algo-turn/","title":"Peterson算法中turn(will_wait)变量的作用"},{"content":"题目要求 A linked list consists of a series of structures, which are not necessarily adjacent in memory. We assume that each structure contains an integer key and a Next pointer to the next structure. Now given a linked list, you are supposed to sort the structures according to their key values in increasing order.\nInput Specification: Each input file contains one test case. For each case, the first line contains a positive N (\u0026lt; 105) and an address of the head node, where N is the total number of nodes in memory and the address of a node is a 5-digit positive integer. NULL is represented by -1.\nThen N lines follow, each describes a node in the format:\nAddress Key Next\nwhere Address is the address of the node in memory, Key is an integer in [-105, 105], and Next is the address of the next node. It is guaranteed that all the keys are distinct and there is no cycle in the linked list starting from the head node.\nOutput Specification: For each test case, the output format is the same as that of the input, where N is the total number of nodes in the list and all the nodes must be sorted order.\nSample Input: 5 00001\n11111 100 -1\n00001 0 22222\n33333 100000 11111\n12345 -1 33333\n22222 1000 12345\nSample Output: 5 12345\n12345 -1 00001\n00001 0 11111\n11111 100 22222\n22222 1000 33333\n33333 100000 -1\n解题思路 首先想到的是通过按照key对所有的node进行排序，然后在输出的时候确定其next地址。\n编写完成之后，发现只通过了两组数据，还有三组数据没有通过。再结合之前做过的相关问题，想到不是所有的node都在该Linked List上。于是开辟另一个数组，用于存储在该Linked List上的所有的节点，再排序输出。\n继续提交后发现，最后一组数据没有通过，而且时间只有1ms。遂想到，有可能是最后一组数据可能是Linked List长度为0的数据。于是对其进行特殊的处理，其head node的地址是-1.\n代码 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct Node { int addr, key, next; }Node; Node node[100000 + 10]; Node nodes[100000 + 10]; bool cmp(const Node \u0026amp;a, const Node \u0026amp;b) { return a.key \u0026lt; b.key; } int main() { int n = 0, start; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;start); int addr, key, next; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;addr, \u0026amp;key, \u0026amp;next); node[addr].addr = addr; node[addr].key = key; node[addr].next = next; } int cnt = 0; int cur = start; while (cur != -1) { nodes[cnt] = node[cur]; cur = node[cur].next; cnt++; } n = cnt; sort(nodes, nodes + n, cmp); if (cnt == 0) { printf(\u0026#34;%d -1\\n\u0026#34;, n); return 0; } printf(\u0026#34;%d %05d\\n\u0026#34;, n, nodes[0].addr); for (int i = 0; i \u0026lt; n - 1; i++) { printf(\u0026#34;%05d %d %05d\\n\u0026#34;, nodes[i].addr, nodes[i].key, nodes[i + 1].addr); } printf(\u0026#34;%05d %d -1\\n\u0026#34;, nodes[n - 1].addr, nodes[n - 1].key); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2016-03-31T00:00:00Z","permalink":"https://jiacs.com/p/pat-1052/","title":"PAT 1052 Linked List Sorting (25)"},{"content":"题目要求 Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, \u0026hellip;, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.\nInput Specification: Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.\nOutput Specification: For each pop sequence, print in one line \u0026ldquo;YES\u0026rdquo; if it is indeed a possible pop sequence of the stack, or \u0026ldquo;NO\u0026rdquo; if not.\nSample Input: 5 7 5 1 2 3 4 5 6 7 3 2 1 7 5 6 4 7 6 5 4 3 2 1 5 6 4 3 7 2 1 1 7 6 5 4 3 2 Sample Output: YES NO NO YES NO 解题思路 本题主要使用了STL中的栈（stack）来模拟一个栈进行操作。\n使用cur记录当前应该入栈的元素，依次读取pop sequence中的元素，对于每个读取到的元素，主要遵循以下几个原则：\n 如果要输出的元素正好是当前栈顶的元素，则栈顶出栈 如果要输出的元素大于等于cur，则将[cur, 要输出元素]这一区间内的元素全部入栈，然后出栈一次。出栈前判断栈是否溢出，如果溢出，则直接输出NO 如果要输出的元素小于cur，并且栈顶不是该元素（出栈得到的不是目的元素），则直接输出NO  一个pop sequence里的元素全部读取处理完毕，并且没有出现错误，则输出YES。\n代码 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;stack\u0026gt; using namespace std; int main() { int num; int m, n, k; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;m, \u0026amp;n, \u0026amp;k); bool ok = true; for (int i = 0; i \u0026lt; k; i++) { stack\u0026lt;int\u0026gt; s; int cur = 1; ok = true; for (int j = 0; j \u0026lt; n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); if (!ok) { continue; } if (!s.empty() \u0026amp;\u0026amp; num == s.top()) { s.pop(); } else if (num \u0026lt; cur \u0026amp;\u0026amp; num != s.top()) { printf(\u0026#34;NO\\n\u0026#34;); ok = false; } else { while (cur \u0026lt;= num) { s.push(cur); cur++; } if (s.size() \u0026gt; m) { printf(\u0026#34;NO\\n\u0026#34;); ok = false; } s.pop(); } } if (ok) { printf(\u0026#34;YES\\n\u0026#34;); } } system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2016-02-29T00:00:00Z","permalink":"https://jiacs.com/p/pat-1051/","title":"PAT 1051 Pop Sequence (25)"},{"content":"题目要求 Zhejiang University has 40000 students and provides 2500 courses. Now given the registered course list of each student, you are supposed to output the student name lists of all the courses.\nInput Specification: Each input file contains one test case. For each case, the first line contains 2 numbers: N (\u0026lt;=40000), the total number of students, and K (\u0026lt;=2500), the total number of courses. Then N lines follow, each contains a student\u0026rsquo;s name (3 capital English letters plus a one-digit number), a positive number C (\u0026lt;=20) which is the number of courses that this student has registered, and then followed by C course numbers. For the sake of simplicity, the courses are numbered from 1 to K.\nOutput Specification: For each test case, print the student name lists of all the courses in increasing order of the course numbers. For each course, first print in one line the course number and the number of registered students, separated by a space. Then output the students' names in alphabetical order. Each name occupies a line.\nSample Input: 10 5 ZOE1 2 4 5 ANN0 3 5 2 1 BOB5 5 3 4 2 1 5 JOE4 1 2 JAY9 4 1 2 5 4 FRA8 3 4 2 5 DON2 2 4 5 AMY7 1 5 KAT3 3 5 4 2 LOR6 4 2 4 1 5 Sample Output: 1 4 ANN0 BOB5 JAY9 LOR6 2 7 ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6 3 1 BOB5 4 7 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 5 9 AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1 解题思路 此题与之前的1039非常类似。首先要对学生的名称进行哈希，得到相应的整数，然后在每个课程对应的vector下面，存储学生姓名的哈希值。同时，在一个数组里，以哈希值为Index存储学生的姓名。\n最后在输出的时候，首先对哈希值进行一遍排序，然后将存储的学生姓名输出即可。\n代码 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; char names[26 * 26 * 26 * 10 + 10][5]; vector\u0026lt;int\u0026gt; c[2510]; int getHash(char *a) { return (a[0] - \u0026#39;A\u0026#39;) * 26 * 26 * 10 + (a[1] - \u0026#39;A\u0026#39;) * 26 * 10 + (a[2] - \u0026#39;A\u0026#39;) * 10 + (a[3] - \u0026#39;0\u0026#39;); } int main() { int n, k; char buf[5]; int course; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (int i = 0; i \u0026lt; n; i++) { int a; scanf(\u0026#34;%s%d\u0026#34;, buf, \u0026amp;a); int hash = getHash(buf); strcpy(names[hash], buf); for (int j = 0; j \u0026lt; a; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;course); c[course].push_back(hash); } } for (int i = 1; i \u0026lt;= k; i++) { int len = c[i].size(); printf(\u0026#34;%d %d\\n\u0026#34;, i, len); sort(c[i].begin(), c[i].end()); for (int j = 0; j \u0026lt; len; j++) { printf(\u0026#34;%s\\n\u0026#34;, names[c[i][j]]); } } system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2016-02-28T00:00:00Z","permalink":"https://jiacs.com/p/pat-1047/","title":"PAT-1047 Student List for Course (25)"},{"content":"题目要求 With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.\nInput Specification: Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax (\u0026lt;= 100), the maximum capacity of the tank; D (\u0026lt;=30000), the distance between Hangzhou and the destination city; Davg (\u0026lt;=20), the average distance per unit gas that the car can run; and N (\u0026lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (\u0026lt;=D), the distance between this station and Hangzhou, for i=1,\u0026hellip;N. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print \u0026ldquo;The maximum travel distance = X\u0026rdquo; where X is the maximum possible distance the car can run, accurate up to 2 decimal places.\nSample Input 1: 50 1300 12 8\n6.00 1250\n7.00 600\n7.00 150\n7.10 0\n7.20 200\n7.50 400\n7.30 1000\n6.85 300\nSample Output 1: 749.17\nSample Input 2: 50 1300 12 2\n7.10 0\n7.00 600\nSample Output 2: The maximum travel distance = 1200.00\n时间要求 10ms\n解题过程 刚开始看到这道题，没有什么思路。看到时间限制这么小，考虑到会不会是使用动归，不过也没有想到应该怎么办。查了网上的资料后，发现是使用贪心算法进行解决。具体的思路如下：\n首先要对所有的加油站按照距离升序排列，记加满之后的最大距离为max，从A加油站向后搜索。搜索的情况有以下几种：\n 若搜索到一个油价比A小的加油站，则在A点加油到刚好能到该加油站 若不满足1， 但搜索到终点，则直接加油到终点 若不满足1、2, 则加满油到能够行驶到所有能到达的加油站里的油价最低的加油站 若不满足1、2、3，则最大距离里没有任何加油站，则最大行驶距离为A+max  需要注意的地方有两点：\n 因为情况3向后继续行驶时，油箱会有剩余油，所以需要记录油箱剩余的油量，而且可能为小数。 有可能没有距离为0的加油站，此时无法行驶。  代码如下：\n#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; typedef struct Station { double price; int d; }Station; Station s[550]; bool cmp(const Station \u0026amp;a, const Station \u0026amp;b) { return a.d \u0026lt; b.d; } int main() { double c; int distance, d, n; scanf(\u0026#34;%lf%d%d%d\u0026#34;, \u0026amp;c, \u0026amp;distance, \u0026amp;d, \u0026amp;n); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%lf%d\u0026#34;, \u0026amp;s[i].price, \u0026amp;s[i].d); } sort(s, s + n, cmp); int max = c * d; if (s[0].d != 0) { printf(\u0026#34;The maximum travel distance = 0.00\\n\u0026#34;); system(\u0026#34;pause\u0026#34;); return 0; } double left = 0, fee = 0, maxDistance = -1; int cur = 0; while (cur \u0026gt;= 0) { int lowerStation = -1; for (int i = cur + 1; i \u0026lt; n \u0026amp;\u0026amp; s[i].d \u0026lt;= s[cur].d + max; i++) { if (s[cur].price \u0026gt; s[i].price) { lowerStation = i; break; } } if (lowerStation != -1) { fee += ((s[lowerStation].d - s[cur].d) / (0.0 + d) - left) * s[cur].price; left = 0; cur = lowerStation; continue; } else { if (s[cur].d + max \u0026gt;= distance) { fee += ((distance - s[cur].d) / (0.0 + d) - left) * s[cur].price; left = 0; cur = -1; } else { int minStation = -1; double minPrice = 100000000; for (int i = cur + 1; i \u0026lt; n \u0026amp;\u0026amp; s[i].d \u0026lt;= s[cur].d + max; i++) { if (s[i].price \u0026lt; minPrice) { minStation = i; minPrice = s[i].price; } } if (minStation != -1) { fee += (c - left) * s[cur].price; left = c - (s[minStation].d - s[cur].d) / (0.0 + d); cur = minStation; } else { maxDistance = s[cur].d + max; cur = -1; } } } } if (maxDistance \u0026gt; 0) { printf(\u0026#34;The maximum travel distance = %.2lf\\n\u0026#34;, maxDistance); } else { printf(\u0026#34;%.2lf\\n\u0026#34;, fee); } system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2016-02-24T00:00:00Z","permalink":"https://jiacs.com/p/pat-1033/","title":"PAT 1033 To Fill or Not to Fill (25)"},{"content":"题目要求 Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 105 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it.\nInput Specification: Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (\u0026lt;=105, the total number of coins) and M(\u0026lt;=103, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space.\nOutput Specification: For each test case, print in one line the two face values V1 and V2 (separated by a space) such that V1 + V2 = M and V1 \u0026lt;= V2. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output \u0026ldquo;No Solution\u0026rdquo; instead.\nSample Input 1: 8 15 1 2 8 7 2 4 11 15 Sample Output 1: 4 11 Sample Input 2: 7 14 1 8 7 2 4 11 15 Sample Output 2: No Solution 解题思路 读完题目之后，首先想到的解法就是先对整个的coin数组进行排序，然后开始遍历整个数组，以当前元素为V1，与后面的元素相加，比较与M的大小，直到找到第一个结果。这样做的时间复杂度是O(N^2)，但是看到题目的时间要求是50ms，我就觉得应该会卡时间，直接用O(n^2)的算法肯定会超时。\n接着，我就想到前几天看网上1044的题解的时候，有人用来降低复杂度的方法是二分法，而这道题用二分法也非常合适！所以只保留之前的外循环，内层循环使用二分法实现，最终一遍通过！\n代码 #include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstdlib\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int coins[100000 + 10]; int m; int main() { int n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, coins + i); } sort(coins, coins + n); int start, end, mid; for (int i = 0; i \u0026lt; n - 1; i++) { start = i + 1; end = n - 1; mid = (start + end) / 2; while (coins[i] + coins[mid] != m \u0026amp;\u0026amp; end \u0026gt;= start \u0026amp;\u0026amp; start \u0026gt;= i + 1 \u0026amp;\u0026amp; end \u0026lt;= n - 1) { if (coins[i] + coins[mid] \u0026lt; m) { start = mid + 1; mid = (start + end) / 2; } else { end = mid - 1; mid = (start + end) / 2; } } if (coins[i] + coins[mid] == m \u0026amp;\u0026amp; mid \u0026gt; i \u0026amp;\u0026amp; mid \u0026lt; n) { printf(\u0026#34;%d %d\\n\u0026#34;, coins[i], coins[mid]); system(\u0026#34;pause\u0026#34;); return 0; } } printf(\u0026#34;No Solution\\n\u0026#34;); system(\u0026#34;pause\u0026#34;); return 0; } ","date":"2016-02-24T00:00:00Z","permalink":"https://jiacs.com/p/pat-1048/","title":"PAT 1048 Find Coins (25)"},{"content":"题目要求 Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query.\nInput Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (\u0026lt;=40000), the number of students who look for their course lists, and K (\u0026lt;=2500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni (\u0026lt;= 200) are given in a line. Then in the next line, Ni student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space.\nOutput Specification: For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student\u0026rsquo;s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line.\nSample Input: 11 5\n4 7\nBOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\n1 4\nANN0 BOB5 JAY9 LOR6\n2 7\nANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6\n3 1\nBOB5\n5 9\nAMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1\nZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9\nSample Output: ZOE1 2 4 5\nANN0 3 1 2 5\nBOB5 5 1 2 3 4 5\nJOE4 1 2\nJAY9 4 1 2 4 5\nFRA8 3 2 4 5\nDON2 2 4 5\nAMY7 1 5\nKAT3 3 2 4 5\nLOR6 4 1 2 4 5\nNON9 0\n时间要求 200ms\n解题过程 一开始做的时候，我感觉这个题应该很简单，只要使用map将学生的名字和一个vector\u0026lt;int\u0026gt; 匹配起来，在读入数据的时候，向名称所对应的vector中不断push_back就可以了。最后输出的时候，先对vector排个序，然后按照题目要求输出就可以了。\n在写完之后，一遍就通过了样例。然后我马上将代码提交的到了oj里，最后发现最后一组数据超时了。\n思考之后，我觉得有可能是最后进行排序的时候超时了，所以又将vector改成了set，并且去掉了sort方法，因为set会默认进行升序排列。提交之后，发现还是超时。\n我继续读题发现，题目中特别提到了学生姓名的规则为前三个字符为大写字母，第四位是一个数字，这应该是非常适合进行哈希的。就考虑到会不会是不断生成string，造成了效率过低。于是我将map修改为一个大小为26 * 26 * 26 * 10 + 1的数组，然后对学生的名字进行哈希，将哈希后的值作为index进行存储。\n提交之后，成功过掉了，最后一个case耗时113ms。\n代码如下：\n/* pass 2016年2月23日 10:52:14 注意：需要对学生名字做hash，否则最后一组数据会超时 */ #include \u0026lt;cstdio\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; const int MAXN = 26 * 26 * 26 * 10 + 1; set\u0026lt;int\u0026gt; list[MAXN]; int hashName(char * buf) { return (buf[0] - \u0026#39;A\u0026#39;) * 26 * 26 * 10 + (buf[1] - \u0026#39;A\u0026#39;) * 26 * 10 + (buf[2] - \u0026#39;A\u0026#39;) * 10 + (buf[3] - \u0026#39;0\u0026#39;); } int main() { char buf[5]; int N, K; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;N, \u0026amp;K); for (int i = 0; i \u0026lt; K; i++) { int index, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;index, \u0026amp;n); for (int j = 0; j \u0026lt; n; j++) { scanf(\u0026#34;%s\u0026#34;, buf); list[hashName(buf)].insert(index); } } for (int i = 0; i \u0026lt; N; i++) { scanf(\u0026#34;%s\u0026#34;, buf); int hname = hashName(buf); int len = list[hname].size(); printf(\u0026#34;%s %d\u0026#34;, buf, len); set\u0026lt;int\u0026gt;::iterator it = list[hname].begin(); for (; it != list[hname].end(); it++) { printf(\u0026#34; %d\u0026#34;, *it); } printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2016-02-23T00:00:00Z","permalink":"https://jiacs.com/p/pat-1039/","title":"PAT 1039 Course List for Student(25)"},{"content":"一眨眼，2015年就过去了。本来早就想总结一下自己的2015，但是最近一直忙着期末考试，一直没有腾出时间来，今天终于有点时间，可以好好地“总结过去，展望未来”了。\n0x00 学习方面 2015年对我来说，是学习成绩真正开始上升的一年。从大二下，就没有了各种各样的数学课、基础课了，都是我熟悉的专业课。这些课，才是我来到大学之前，想象的自己要学习的课程。\n有了兴趣，学习成绩当然也不会太差，基本上每一门都差不多达到了我自己的要求。\n大二下：\n 计算机组成原理：95分 数据结构：94分 计算机科学与技术专业导论：A  大三上：\n Web开发技术：A+ 网络与信息安全：A+ 专业实践与训练I：A+ 计算机网络原理：99 数据库原理：94 汇编与接口技术：97  总体来说，学习成绩终于不再拖后腿，开始把之前欠的绩点往回补了。\n0x01 技术积累 2015年，我的专业技能的积累还是和以前一样，没有太过明显的进步，只在慢慢地积累。也许是厚积薄发吧，也可能是因为自己的精力太过分散，没有找到自己的方向。\n值得记录的事情有：\n 终于签约成为了极客学院的布道师，开始有自己的正常收入，并且基本实现了目前阶段的财务自由。 自己带领的大学生创新创业项目，成为了国家级项目，应该可以顺利结题了。 参加信息安全竞赛，虽然项目没有获奖，但是自己对于SVM的应用（仅限于应用）有了一定的了解，可以考虑将其应用在其他的项目中了。 对JavaWeb的开发有了入门的基础，初步了解了SpringMVC、Spring、Mybatis等框架的搭建与使用。 了解了PHP的Laravel框架，并且有了之前SpringMVC的基础，在很短的时间内，就用Laravel框架搭建了一个简单的图书馆管理系统，作为数据库原理的课程设计。 使用树莓派控制小车的运动。（项目已弃，当作自己的一点经验吧） 发现了国内众多邮箱的SMTP用户名伪造方式。 参加了PAT甲级考试，知道了自己还需要好好提升Orz。  基本上就上面这一些吧，还有些零零碎碎的东西就不罗嗦了。\n当然自己也还存在不少的问题，对于自己未来的出路也不太清楚。不确定能不能保研，还有自己的方向也不太清楚。这也造成了自己精力的分散，虽然尝试了不少的东西，但是很多都是浅尝辄止，没有深入，也没有取得很好的成果。\n0x02 其他 读书方面，自己定下的2015书单没有看完，有些书还得2016接着读。\n附2015年读完的书：\n 明朝那些事儿 PPT演示之道 我是一只IT小小鸟 人性的弱点 奇特的一生  0x03 2016新年展望 2016年，又是决定命运的一年。未来的出路将在这一年决定，就像3年前的高考。\n列一下2016计划要做的事情：\n PAT甲级考到80分以上 找到自己的方向 多参与Github上的项目，丰富自己的项目经历 GPA好好刷好，争取4.2以上吧 做好准备，找好暑期实习 多更新博客 锻炼身体  啰啰嗦嗦说了这么多，其实行动最重要，希望自己能够收好心，完成这重要的一年吧。\n","date":"2016-01-14T00:00:00Z","permalink":"https://jiacs.com/p/2015-conclusion/","title":"2015の总结\u0026\u00262016の计划"},{"content":"一般来说，我们收到一封邮件之后，都会首先看发件人。有些重要的邮件，比如Apple给你发的重置密码邮件，手机丢失邮件等等，我们都会反复查验发件人，确认是真的来自Apple的官方，而不是钓鱼邮件。然而，如果这个发件人信息是可以伪造的，你还能知道是谁给你发的邮件吗？ 前一段时间，学习SMTP邮件协议的时候，写了个简单的发件程序，却发现了一个很多邮箱都存在的发件人伪造问题。 想看伪造结果的，请直接拉到最下面看截图。\n0x00 邮件发送流程 在谈论问题之前，我们首先要了解邮件到底是怎么发送给对方的。下面这幅图是一个简单的发件流程： 其中的Local Mail Server就是发件人的邮箱服务器，Remote Mail Server就是收件人的邮箱服务器。 发件人从Sender Main Client（可以是本地客户端程序, 比如foxmail、outlook，也可以是邮箱网页版）发送邮件之后，会首先通过SMTP协议到达Local Mail Server，然后由Local Mail Server同样通过SMTP协议将邮件投递到Remote Mail Server，之后收件人就可以在任意时间从自己的邮件服务器上收到邮件了。\n0x01 SMTP协议 SMTP协议也就是简单邮件传输协议，上面我们说到，有两个地方都用到了SMTP协议。 那么我们接着就看看SMTP协议是怎么工作的（下面是两个终端之间建立TCP连接后传输的数据，S为接收方，C为发送方）：\nS：220 163.com Anti-spam GT for Coremail System (163com[071018]) C：HELO smtp.163.com S：250 OK /***************************** C：auth login S：334 dXNlcm5hbWU6 C：USERbase64加密后的用户名 S：334 UGFzc3dvcmQ6 C：PASSbase64加密后的密码 S：235 Authentication successful ******************************/ C：MAIL FROM: \u0026lt;xxx@163.com\u0026gt; S：250 Mail OK C：RCPT TO:\u0026lt;XXX@163 .COM\u0026gt; S：250 Mail OK C：DATA S：354 End data with . C：From: xxx@163.com C：To: xx@163.com C：Subject: This is a test mail! C：. S：250 Mail OK S：queued as smtp5,D9GowLArizfIFTpIxFX8AA==.41385S2 以上就是一个发送邮件的简单的例子,其中***之间的部分是从client到Local Mail Server这一步需要的，从Local Mail Server到Remote Mail Server是不需要的。\n经过了上面的步骤，就可以将一封邮件发送到对方的邮箱了。\n0x02 发件人伪造 知道了原理，我们就可以从这中间找破绽了。从上面的这段数据中，我们可以发现，关于发件人的部分一共有两个部分，一部分是\nC：MAIL FROM: \u0026lt;xxx@163.com\u0026gt; 还有一部分在：\nC：From: xxx@163.com C：To: xx@163.com C：Subject: This is a test mail! 其中，第一部分是通知邮件服务器发件人信息的，第二部分是邮件的具体内容，主要是在邮件的显示过程中，显示给用户看的，这部分可以随意修改，不会有影响。 真正有影响的是第一部分。这一部分是真正指示邮件发件人姓名的。有时候，修改了第二部分，邮箱会提示你，该邮件由XXX代发，其中的XXX就是真正的发件人。这说明有的邮箱会验证这两部分是否相同，如果不相同，就会提示用户。 而如果修改了第一部分会怎么样呢？\n0x03 邮箱服务商的漏洞 为了能够伪造第一部分的收件人信息，我们采用的方法是，编写程序，模拟Local Mail Server，直接向对方的邮件服务器发送邮件。 这时，你可能会问，我们伪造的话，不会被对方发现吗？这就是部分邮箱服务商的漏洞所在！他们对于邮件的发送服务器并没有进行验证，而是无条件地信任了！也就是说，我说我是苹果的服务器，他就认为我是苹果的服务器！ 正常来说，我们认为Remote Mail Server 收到邮件时，会进行反向验证，也就是你提供的发件人的邮件域名（@后面的部分）对应的MX记录与发件服务器的IP地址是否匹配，如果匹配的话，那么就认为没有问题，接收邮件；如果不匹配的话，就会拒收邮件。 而如果不进行认证的话，就可以随意进行伪造了。 我使用的程序是在计算机网络原理课上编写的一个小程序（伪造成本如此之低！）。\n当过给一个有验证的服务器发送邮件的时候，结果是这样的(我交的服务器还不错)： 而如果我给一个没有验证的服务器发送邮件的时候，结果是这样的（没错，黑的就是你，QQ邮箱！）： 然后我就会收到这样的邮件： 嗯，如果把内容好好改一改，一封钓鱼邮件是不是就成功了呢^_^\n当然，我是一个公平的人，怎么能只黑QQ邮箱呢，于是我把国内外几个常用的邮箱都试了一下，然后： 嗯，看来不光是国内的问题，outlook也沦陷了。虽然有的被放到了垃圾邮件里，但是全部都收到了，而且并没有提示发件人有什么问题哦。\n当然，还有一个没沦陷的，Gmail 这里提示的错误好像跟IPV6有关，但是我关闭IPV6之后，好像也被anti-spam系统拦下了，不知道有没有别的办法能突破，但是起码不是一下子就被突破了啊喂！\n在我的测试中，只有我交的邮件服务器和Gmail没有发送成功，其他几个邮箱都收到了，其他还有多少邮箱存在这个问题我也不知道。\n0x04 小结 这只是我在完成一个小作业的时候偶然发现的漏洞，当然，有可能各大邮箱服务商有自己的考虑，（比如兼容别的邮件服务器什么的？我不了解），所以没有进行反向验证。 但是伪造发件人的这个漏洞是的的确确存在的，也不排除有人会利用这个漏洞干坏事，大家以后还是要认真识别啊（好像并没有什么有效的方法啊。。。）\n","date":"2016-01-09T00:00:00Z","permalink":"https://jiacs.com/p/fake-mail-sender/","title":"你真的知道谁给你发的邮件吗？——邮件发件人伪造"},{"content":"问题： 如何判断一个链表是否有闭环？\n今天看到了这个问题，提到了Floyd判圈算法，于是去查了一下这个算法，把自己的一点想法写下来。\n问题的答案是： 从链表的头部设置两个指针，p1的步长为1， p2的步长为2，同时向前走，如果p1和p2最终能够相遇，则说明链表是有环的。\n检测环的基本思想是非常简单的，可以类比成两个人在跑道上跑。只要有圈，跑的快的那个人就一定能够追上跑得慢的那个人。\n另外，还有两个相关的问题，一个是如何求环的长度，另一个是如何求环的起点。\n求环的长度 这个也能非常简单的想到：\n两个人相遇的是时候，一定已经在环上了，然后两个人只要再次在环上接着跑，再次相遇的时候（也就是所谓的套圈），跑的快的那个人就比跑得慢的人整整多跑了一圈，所以环的长度也就出来了。\n用算法来描述，也就是第一次相遇后，p1和p2按照原来的步长继续向前查找，并且记录下两个指针遍历过的节点个数。当两个指针再次相遇的时候，遍历的节点数量差就是环的长度了。\n第二个就是求环的起点 解决方法是把其中的一个指针重置到链表头部，然后两个指针步长都为1，继续向前移动，相遇的位置即为环的起点。\n方法的解析如下： 首先我们设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m, 环的长度为n，相遇的位置与起点位置距离为k。 则可以得到: i = m + a * n + k\n其中a为慢指针走的圈数。 根据快指针和慢指针的速度关系，我们可以得到另一个式子: 2 * i = m + b * n + k\n其中b为快指针走的圈数。 简单处理得到: i = (b - a) * n\n也就是说i是圈长的整数倍。 这时将其中一个节点放到起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点i + m, i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。\n","date":"2015-11-30T00:00:00Z","permalink":"https://jiacs.com/p/floyd-algo/","title":"Floyd判圈算法（龟兔赛跑算法）"},{"content":"前段时间做了NSCTF的比赛，做出了其中的几道题目，下面对几道题目的解题过程进行简单的分析。\n1. Crypto50 神奇的字符串 题目： 解题过程： 观察题目中的字符串，应该是进行了加密之后得到的字符串。利用网上的解密工具进行Base64解密，AES解密等解密工具以后发现，是使用了AES进行了加密。解密后的密文为：\n flag{DISJV_Hej_UdShofjyed}\n 根据NSCTF的flag规则，flag应该是以**“NSCTF_”**开头的，而解密后得到的结果的前几位是**“DISJV”**, 猜测是否使用了最常见的移位方法进行了加密。 于是进行一下验证，首先将DISJV几个字母与NSCTF对应\n原：ABCDEFGHIJKLMNOPQRSTUVWXYZ 移： S V D IJ 进行补全后如下：\n原：ABCDEFGHIJKLMNOPQRSTUVWXYZ 移：QRSTUVWXYZABCDEFGHIJKLMNOP 发现能够完全对应。于是将flag中剩下的字母按照大小写进行对应，最终得到最后的flag：\n NSCTF_Rot_EnCryption\n 2. Web200 Decode 题目要求： 本题目的要求比较简单，是针对一个已经给出源代码的PHP加密函数，解密加密后的密文。\n解题过程： 根据题目要求，只需要弄懂加密代码中的使用的几种加密方法即可。\n要解密文，只需要按照与加密顺序相反的顺序进行解密即可。\n首先分析源代码，我们可以看到最后进行的操作是str_rot13这个函数。我们查看这个函数的介绍：\nstr_rot13() 函数对字符串执行 ROT13 编码。 ROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。 提示：编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。 从这里我们可以清楚地知道，rot13编码的加密和解密函数其实是同一个函数，只要对密文再进行一遍rot13编码即可解密。因此我们的第一步就是再次调用str_rot13函数，处理密文。\n然后，我们可以看到倒数第二步进行的操作是strrev函数，这个函数是对字符串进行反转，也就是倒序输出。很明显，要还原密文，只需要再次调用strrev函数对上一步的密文进行处理即可。\n接着，我们发现加密算法还对密文进行了base64加密，只需要调用base64_decode函数就可以解密。\n接着，我们再来分析上面的for循环中的内容。从for循环上面的语句来看，我们知道$_o中的字符串应该是原文的倒序。 然后我们来看for循环对$_o这个函数进行了怎样的操作:\n第一步是看循环的次数，我们可以清楚的看出是循环了strlen($_o)次，也就是与$_o的长度等长。 然后$_c = substr($_o, $_O, 1)这个是从字符串的第$_O个位置截取1个字符出来，赋值给$_c。 接着$__ = ord($_c) + 1和$_c = chr($__)两句的意思是，先将刚才的字符转换为ascii码，加1以后再转回字符。 最后再把这个新的字符挨个连接起来生成$_这个变量。\n综合来看，其实就是将原文中所有的字符都加1。那我们要解密的话也可以使用类似的方法，对密文中所有的字符循环减1。这样就得到了$_o中的内容。\n然后我们说过,$_o和$str中的数据是相互逆序的关系，我们只需要再对$_o进行一遍逆序，就可以得到原文了！\n以下是解密函数的代码：\n\u0026lt;?php $sec = \u0026quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\u0026quot;; $sec = str_rot13($sec); $sec = strrev($sec); $sec = base64_decode($sec); for($i = strlen($sec) - 1; $i \u0026gt;= 0; $i--) { $c = substr($sec, $i, 1); $__ = ord($c) - 1; $c = chr($__); $_ = $c.$_; } echo strrev($_); ?\u0026gt; 在php服务器上执行以上代码，就可以得到原文。\n3.MISC250 WireShark 题目要求： 解题思路： 首先根据题目的描述，使用wireshark打开下载到的文件。题目中描述，这里面有室友下载的小东东。 既然是下载的内容，首先考虑的就是HTTP协议和FTP协议，然后在记录中查找可以找到下面的记录。\n划红线的部分可以看到，用户下载了一个key.rar的文件。然后我们找到下面一个从服务器发来的包，就可以找到key.rar的文件的内容。 将数据dump到文件中发现，是一个加密的rar文件。\n继续在抓到的包中寻找发现，在rar之前的http包中发现，用户还浏览过一个html文件，使用相同的方式将html文件保存下来，打开后发现文件内容大概是这样：\n 密码是nsfocus+5位数字\n 接下来就只能使用暴力破解了，这里我使用的是ARCHPR 4.54这个软件，但是由于密码规则比较特殊，前几位是固定的字母，而最后五位是数字，使用其默认的规则有些困难。 因此，我手动编写了一个小程序，将所有nsfocus+5位数字的可能性全部输出到了一个文件里，将这个文件作为字典文件，使用字典类型的破解，最终获取了密码，然后得到了该文件中的flag。\n4.MISC400 小绿的女神 题目要求： 这个题目有点特殊，是上传一个card文件，模拟刷卡，然后可以在网页上模拟消费和查询余额两个操作。\n解题过程： 拿到这个题目，首先上传card文件上去，然后点击查询余额，发现显示了余额，并且页面中显示了card文件的16进制内容，然后再次进行刷卡操作，提示消费了**元，并且更新了显示的card的内容。 注意到操作前后显示的内容是不同的， 因此可以猜测，变化的部分就是存储卡的余额的相关部分。 使用文件对比工具，比较一下变化的内容：\n可以看到0x40和0xC0那两行有变化。再次仔细对比可以发现，0xC0~0xC3部分表示的是当前余额：\n余额为 96.41， 0xC0~0xC3部分内容为 A9 25 00 00。应该是按照内存中数据的存储方式，高位数据在内存地址大的位置。也就是说其值应该为00 00 25 A9,即9641。\n而0xC4~0xC7部分是0xFFFFFFFF减去余额。 直接修改该部分和其后相同的部分发现，系统提示不通过，也就是卡片内容修改之后不能通过系统的验证了。继续观察发现： 继续观察发现，另一部分发生变化的0x40~0x43与0xC0~0xC3部分的和是不变的！\n将两部分对应好之后修改发现，卡片的余额确实发生了变化，但是不能达到预期的数字。因为即使把0x40~0x43部分改成0，也不能余额达到208那么大的数字。也就是说这两部分的总和根本就不到208，只修改这两部分肯定不能达到要求。\n这是我们继续观察发现，0x80那一行的数据也与其他为00的数据不同，肯定与其他数据有关联。经过计算发现，0x80那一行的数据就是0x40和0xC0的和，0x80的数据就是卡片的总和！ 这样就很简单了，只需要将0x80那一行的数据改成足够大，然后把0xC0部分修改为 40 51 00 00 (其他部分相应修改)就可以查询到208的余额了！然后就能看到弹出的flag了。\n总结 本次比赛中我共得到了1200分，虽然做出了一部分的题。但是感觉做起来比较艰难，在Web、逆向等方面的经验和能力明显不足，希望以后能够不断积累经验提高自己的水平。\n","date":"2015-10-04T00:00:00Z","permalink":"https://jiacs.com/p/nsctf-2015/","title":"NSCTF2015部分题目解析"},{"content":"本学期开始学习汇编了，但是无奈学的东西都是好久之前的老知识了，在现在的电脑上实践起来略有困难，连debug命令都没法用。 最后在参考老师给的资料和网上相关资料的基础上，完成了汇编开发环境的搭建，做下记录，以备后用。\n整个开发环境的搭建主要有以下几步：\n Dos模拟器DosBox的安装和本地文件夹的挂载 masm、link、debug等工具的安装 环境变量的配置 自动运行脚本的配置  以上是基本步骤。文中所用到的各个软件可以在这里下载\n下面开始正式的安装和搭建过程。\n0x0. Dos模拟器DosBox的安装和本地文件夹的挂载 从上面的压缩包中找到DosBox的安装文件，安装即可。安装完成后可以桌面或者开始菜单的图标打开DosBox.如下图：\n可以看到它默认的系统盘是Z盘。 下面我们可以通过以下命令将本地电脑的一个文件夹挂载到DosBox中：\nmount c e:\\masm611 这条命令的含义就是将本地的e:\\masm611这个文件夹挂载到DosBox中的C盘里。 也就是说你在DosBox中访问C盘的资源就可以看到这个文件夹中的内容了。 可以通过\nc: dir 这两条命令查看到其中的内容。\n0x1. masm、link、debug等工具的安装 我们在进行汇编编程的过程中，上面说的这几个工具都是非常常用的。Masm是编译器，link是链接器，debug是用来调试程序的。\n首先我们来安装masm，这里我使用的是Masm6.11的安装版，我没有尝试过只使用一个masm.exe文件是否能够成功，可以自行尝试。 把压缩包中的Masm611.zip中的几个文件夹解压到刚才挂载的文件夹中（e:\\masm611），然后从DosBox中进入DISK1文件夹，运行其中的setup.exe:\ncd DISK1 回车 setup 回车 这时你就可以看到上古时代的软件安装界面了^_^\n按照提示首先按回车继续，然后选择Install the Macro Assembler using defaults：\n然后选择安装位置，我们选择刚刚挂载的C盘。\n然后确认我们的选择。我们选择NO CHANGES继续安装即可。\n最后等待一会儿之后就可以安装完成了。（确实要等一会儿）\n回到命令输入界面后，我们可以通过cd命令进入到c:\\masm611\\bin这个目录，然后通过dir命令查看所有文件，如果你能找到 masm.exe这个文件，那么你这一步你就成功了。\n接着我们安装link和debug工具。其实不算安装，只要在windows中将压缩包里的两个exe文件复制到E:\\masm611\\masm611\\bin这个文件夹里就可以了。 然后在DosBox里再次查看c:\\masm611\\bin这个目录，能看到刚复制进去的两个文件就OK了。如果看不到的话，就执行下面这条命令再查看：\nrescan 这条命令是用来清除磁盘缓存的。\n最后，你的文件夹里应该是这样的：\n0x2. 环境变量的配置 我们现在已经可以使用使用masm、Link、debug这些命令进行汇编的编程了，但是每次都要输入全路径很麻烦，所以要通过配置环境变量来简化我们的操作。 相信学习过java开发的人都了解环境变量的作用了。在dos下设置环境变量只需要一条命令就行：\nset PATH=%PATH%;c:\\masm611\\bin\\; 也就是在原来的PATH的基础上，再加入c:\\masm611\\bin这个路径，也就是我们的masm等文件所在的路径。 执行完上面的命令之后，你应该就可以直接在里面输入:\nmasm 来运行masm程序了。like this:\n这样这一步也成功完成了。\n0x3. 自动运行脚本的配置 到这里，其实你已经可以愉快的开发了。然而当你下次再打开DosBox的时候，你会发现：\n\u0026quot;WTF？C盘怎么不见了！？\u0026quot; \u0026quot;我的masm命令怎么运行不了了？！\u0026quot; ... 这是因为你刚才做的配置都不能保存，关闭DosBox之后就都没了~_~ 为了解决这个问题，我们可以对DosBox进行配置，让它在每次启动的时候自动为我们执行上面的操作。\n在打开DosBox的时候，你应该会看到除了DosBox的窗口之外，还启动了另一个命令行窗口。\n然后我画红线的位置就是配置文件所在的地方，使用文本(ji)编(shi)辑(ben)器打开这个文件，然后找到最后的[autoexec]部分，在后面追加以下命令：\nmount c e:\\masm611 set PATH=%PATH%;c:\\masm611\\bin\\; 别忘记保存。这时，你再重新打开DosBox试试，发现启动完成之后，它已经自动执行了这两条命令了。这时就可以直接使用masm等命令了！\n0x4. 备注 我的安装过程中并没有在DosBox安装文本编辑器来编辑代码，因为我不想在Dos的命令行中写代码。 代码可以直接在e:\\masm611这个文件夹中写，然后进DosBox编译链接调试就行，我相信大家还是更爱windows下的文本编辑器吧。\n当然如果你非要在Dos下编辑文件的话，可以去网上找一个Dos下的edit.exe复制到DosBox里面使用。\n","date":"2015-09-27T00:00:00Z","permalink":"https://jiacs.com/p/8086-dev-env-build/","title":"8086汇编开发环境搭建"}]