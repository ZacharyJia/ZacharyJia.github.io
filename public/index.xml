<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Zachary&#39;s Blog</title>
        <link>https://blog.zacharyjia.me/</link>
        <description>Recent content on Zachary&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 28 May 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.zacharyjia.me/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Floyd判圈算法（龟兔赛跑算法）</title>
        <link>https://blog.zacharyjia.me/p/floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95/</link>
        <pubDate>Mon, 30 Nov 2015 00:00:00 +0000</pubDate>
        
        <guid>https://blog.zacharyjia.me/p/floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;h2 id=&#34;问题&#34;&gt;问题：&lt;/h2&gt;
&lt;p&gt;如何判断一个链表是否有闭环？&lt;/p&gt;
&lt;p&gt;今天看到了这个问题，提到了Floyd判圈算法，于是去查了一下这个算法，把自己的一点想法写下来。&lt;/p&gt;
&lt;h3 id=&#34;问题的答案是&#34;&gt;问题的答案是：&lt;/h3&gt;
&lt;p&gt;从链表的头部设置两个指针，p1的步长为1， p2的步长为2，同时向前走，如果p1和p2最终能够相遇，则说明链表是有环的。&lt;/p&gt;
&lt;p&gt;检测环的基本思想是非常简单的，可以类比成两个人在跑道上跑。只要有圈，跑的快的那个人就一定能够追上跑得慢的那个人。&lt;/p&gt;
&lt;p&gt;另外，还有两个相关的问题，一个是如何求环的长度，另一个是如何求环的起点。&lt;/p&gt;
&lt;h3 id=&#34;求环的长度&#34;&gt;求环的长度&lt;/h3&gt;
&lt;p&gt;这个也能非常简单的想到：&lt;/p&gt;
&lt;p&gt;两个人相遇的是时候，一定已经在环上了，然后两个人只要再次在环上接着跑，再次相遇的时候（也就是所谓的套圈），跑的快的那个人就比跑得慢的人整整多跑了一圈，所以环的长度也就出来了。&lt;/p&gt;
&lt;p&gt;用算法来描述，也就是第一次相遇后，p1和p2按照原来的步长继续向前查找，并且记录下两个指针遍历过的节点个数。当两个指针再次相遇的时候，遍历的节点数量差就是环的长度了。&lt;/p&gt;
&lt;h3 id=&#34;第二个就是求环的起点&#34;&gt;第二个就是求环的起点&lt;/h3&gt;
&lt;p&gt;解决方法是把其中的一个指针重置到链表头部，然后两个指针步长都为1，继续向前移动，相遇的位置即为环的起点。&lt;/p&gt;
&lt;p&gt;方法的解析如下：
首先我们设第一次相遇的时候慢指针走过的节点个数为i，设链表头部到环的起点的长度为m, 环的长度为n，相遇的位置与起点位置距离为k。
则可以得到:
&lt;code&gt;i = m + a * n + k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中a为慢指针走的圈数。
根据快指针和慢指针的速度关系，我们可以得到另一个式子: 
&lt;code&gt;2 * i = m + b * n + k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中b为快指针走的圈数。
简单处理得到:
&lt;code&gt;i = (b - a) * n&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也就是说i是圈长的整数倍。
这时将其中一个节点放到起点，然后同时向前走m步时，此时从头部走的指针在m位置。而从相遇位置开始走的指针应该在距离起点&lt;code&gt;i + m&lt;/code&gt;, i为圈长整数倍，则该指针也应该在距离起点为m的位置，即环的起点。&lt;/p&gt;</description>
        </item>
        <item>
        <title>NSCTF2015部分题目解析</title>
        <link>https://blog.zacharyjia.me/p/nsctf2015%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Sun, 04 Oct 2015 00:00:00 +0000</pubDate>
        
        <guid>https://blog.zacharyjia.me/p/nsctf2015%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;p&gt;前段时间做了NSCTF的比赛，做出了其中的几道题目，下面对几道题目的解题过程进行简单的分析。&lt;/p&gt;
&lt;h2 id=&#34;1-crypto50-神奇的字符串&#34;&gt;1. Crypto50 神奇的字符串&lt;/h2&gt;
&lt;h3 id=&#34;题目&#34;&gt;题目：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgcrypto50.png&#34; alt=&#34;crypto50&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;解题过程&#34;&gt;解题过程：&lt;/h3&gt;
&lt;p&gt;观察题目中的字符串，应该是进行了加密之后得到的字符串。利用网上的解密工具进行Base64解密，AES解密等解密工具以后发现，是使用了AES进行了加密。解密后的密文为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;flag{DISJV_Hej_UdShofjyed}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据NSCTF的flag规则，flag应该是以**“NSCTF_”**开头的，而解密后得到的结果的前几位是**“DISJV”**,
猜测是否使用了最常见的移位方法进行了加密。
于是进行一下验证，首先将DISJV几个字母与NSCTF对应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原：ABCDEFGHIJKLMNOPQRSTUVWXYZ

移：  S  V       D    IJ
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进行补全后如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原：ABCDEFGHIJKLMNOPQRSTUVWXYZ

移：QRSTUVWXYZABCDEFGHIJKLMNOP
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现能够完全对应。于是将flag中剩下的字母按照大小写进行对应，最终得到最后的flag：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NSCTF_Rot_EnCryption&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2-web200-decode&#34;&gt;2. Web200 Decode&lt;/h2&gt;
&lt;h3 id=&#34;题目要求&#34;&gt;题目要求：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgweb200Decode.png&#34; alt=&#34;web200Decode&#34;  /&gt;
本题目的要求比较简单，是针对一个已经给出源代码的PHP加密函数，解密加密后的密文。&lt;/p&gt;
&lt;h3 id=&#34;解题过程-1&#34;&gt;解题过程：&lt;/h3&gt;
&lt;p&gt;根据题目要求，只需要弄懂加密代码中的使用的几种加密方法即可。&lt;/p&gt;
&lt;p&gt;要解密文，只需要按照与加密顺序相反的顺序进行解密即可。&lt;/p&gt;
&lt;p&gt;首先分析源代码，我们可以看到最后进行的操作是&lt;code&gt;str_rot13&lt;/code&gt;这个函数。我们查看这个函数的介绍：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;str_rot13() 函数对字符串执行 ROT13 编码。

ROT-13 编码是一种每一个字母被另一个字母代替的方法。这个代替字母是由原来的字母向前移动 13 个字母而得到的。数字和非字母字符保持不变。

提示：编码和解码都是由相同的函数完成的。如果您把一个已编码的字符串作为参数，那么将返回原始字符串。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从这里我们可以清楚地知道，rot13编码的加密和解密函数其实是同一个函数，只要对密文再进行一遍rot13编码即可解密。因此我们的第一步就是再次调用&lt;code&gt;str_rot13&lt;/code&gt;函数，处理密文。&lt;/p&gt;
&lt;p&gt;然后，我们可以看到倒数第二步进行的操作是&lt;code&gt;strrev&lt;/code&gt;函数，这个函数是对字符串进行反转，也就是倒序输出。很明显，要还原密文，只需要再次调用&lt;code&gt;strrev&lt;/code&gt;函数对上一步的密文进行处理即可。&lt;/p&gt;
&lt;p&gt;接着，我们发现加密算法还对密文进行了base64加密，只需要调用&lt;code&gt;base64_decode&lt;/code&gt;函数就可以解密。&lt;/p&gt;
&lt;p&gt;接着，我们再来分析上面的for循环中的内容。从for循环上面的语句来看，我们知道$_o中的字符串应该是原文的倒序。
然后我们来看for循环对$_o这个函数进行了怎样的操作:&lt;/p&gt;
&lt;p&gt;第一步是看循环的次数，我们可以清楚的看出是循环了&lt;code&gt;strlen($_o)&lt;/code&gt;次，也就是与$_o的长度等长。
然后&lt;code&gt;$_c = substr($_o, $_O, 1)&lt;/code&gt;这个是从字符串的第$_O个位置截取1个字符出来，赋值给$_c。
接着&lt;code&gt;$__ = ord($_c) + 1&lt;/code&gt;和&lt;code&gt;$_c = chr($__)&lt;/code&gt;两句的意思是，先将刚才的字符转换为ascii码，加1以后再转回字符。
最后再把这个新的字符挨个连接起来生成$_这个变量。&lt;/p&gt;
&lt;p&gt;综合来看，其实就是将原文中所有的字符都加1。那我们要解密的话也可以使用类似的方法，对密文中所有的字符循环减1。这样就得到了$_o中的内容。&lt;/p&gt;
&lt;p&gt;然后我们说过,$_o和$str中的数据是相互逆序的关系，我们只需要再对$_o进行一遍逆序，就可以得到原文了！&lt;/p&gt;
&lt;p&gt;以下是解密函数的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$sec = &amp;quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&amp;quot;;

$sec = str_rot13($sec);
$sec = strrev($sec);
$sec = base64_decode($sec);

for($i = strlen($sec) - 1; $i &amp;gt;= 0; $i--) 
{
	$c = substr($sec, $i, 1);
	$__ = ord($c) - 1;
	$c = chr($__);
	$_ = $c.$_;
}

echo strrev($_);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在php服务器上执行以上代码，就可以得到原文。&lt;/p&gt;
&lt;h2 id=&#34;3misc250-wireshark&#34;&gt;3.MISC250 WireShark&lt;/h2&gt;
&lt;h3 id=&#34;题目要求-1&#34;&gt;题目要求：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgwireshark.png&#34; alt=&#34;wireshark&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;解题思路&#34;&gt;解题思路：&lt;/h3&gt;
&lt;p&gt;首先根据题目的描述，使用wireshark打开下载到的文件。题目中描述，这里面有室友下载的小东东。
既然是下载的内容，首先考虑的就是HTTP协议和FTP协议，然后在记录中查找可以找到下面的记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgwireshark2.png&#34; alt=&#34;wireshark2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;划红线的部分可以看到，用户下载了一个key.rar的文件。然后我们找到下面一个从服务器发来的包，就可以找到key.rar的文件的内容。
将数据dump到文件中发现，是一个加密的rar文件。&lt;/p&gt;
&lt;p&gt;继续在抓到的包中寻找发现，在rar之前的http包中发现，用户还浏览过一个html文件，使用相同的方式将html文件保存下来，打开后发现文件内容大概是这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;密码是nsfocus+5位数字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来就只能使用暴力破解了，这里我使用的是ARCHPR 4.54这个软件，但是由于密码规则比较特殊，前几位是固定的字母，而最后五位是数字，使用其默认的规则有些困难。
因此，我手动编写了一个小程序，将所有nsfocus+5位数字的可能性全部输出到了一个文件里，将这个文件作为字典文件，使用字典类型的破解，最终获取了密码，然后得到了该文件中的flag。&lt;/p&gt;
&lt;h2 id=&#34;4misc400-小绿的女神&#34;&gt;4.MISC400 小绿的女神&lt;/h2&gt;
&lt;h3 id=&#34;题目要求-2&#34;&gt;题目要求：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgcard.png&#34; alt=&#34;card&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;这个题目有点特殊，是上传一个card文件，模拟刷卡，然后可以在网页上模拟消费和查询余额两个操作。&lt;/p&gt;
&lt;h3 id=&#34;解题过程-2&#34;&gt;解题过程：&lt;/h3&gt;
&lt;p&gt;拿到这个题目，首先上传card文件上去，然后点击查询余额，发现显示了余额，并且页面中显示了card文件的16进制内容，然后再次进行刷卡操作，提示消费了**元，并且更新了显示的card的内容。
注意到操作前后显示的内容是不同的， 因此可以猜测，变化的部分就是存储卡的余额的相关部分。
使用文件对比工具，比较一下变化的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgcard2.png&#34; alt=&#34;card2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;可以看到0x40和0xC0那两行有变化。再次仔细对比可以发现，0xC0~0xC3部分表示的是当前余额：&lt;/p&gt;
&lt;p&gt;余额为 96.41， 0xC0~0xC3部分内容为 A9 25 00 00。应该是按照内存中数据的存储方式，高位数据在内存地址大的位置。也就是说其值应该为00 00 25 A9,即9641。&lt;/p&gt;
&lt;p&gt;而0xC4~0xC7部分是0xFFFFFFFF减去余额。
直接修改该部分和其后相同的部分发现，系统提示不通过，也就是卡片内容修改之后不能通过系统的验证了。继续观察发现：
继续观察发现，另一部分发生变化的0x40~0x43与0xC0~0xC3部分的和是不变的！&lt;/p&gt;
&lt;p&gt;将两部分对应好之后修改发现，卡片的余额确实发生了变化，但是不能达到预期的数字。因为即使把0x40~0x43部分改成0，也不能余额达到208那么大的数字。也就是说这两部分的总和根本就不到208，只修改这两部分肯定不能达到要求。&lt;/p&gt;
&lt;p&gt;这是我们继续观察发现，0x80那一行的数据也与其他为00的数据不同，肯定与其他数据有关联。经过计算发现，0x80那一行的数据就是0x40和0xC0的和，0x80的数据就是卡片的总和！
这样就很简单了，只需要将0x80那一行的数据改成足够大，然后把0xC0部分修改为 40 51 00 00 (其他部分相应修改)就可以查询到208的余额了！然后就能看到弹出的flag了。&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgscore2.png&#34; alt=&#34;score2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgscore.png&#34; alt=&#34;score&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;本次比赛中我共得到了1200分，虽然做出了一部分的题。但是感觉做起来比较艰难，在Web、逆向等方面的经验和能力明显不足，希望以后能够不断积累经验提高自己的水平。&lt;/p&gt;</description>
        </item>
        <item>
        <title>8086汇编开发环境搭建</title>
        <link>https://blog.zacharyjia.me/p/8086%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <pubDate>Sun, 27 Sep 2015 00:00:00 +0000</pubDate>
        
        <guid>https://blog.zacharyjia.me/p/8086%E6%B1%87%E7%BC%96%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        <description>&lt;p&gt;本学期开始学习汇编了，但是无奈学的东西都是好久之前的老知识了，在现在的电脑上实践起来略有困难，连&lt;code&gt;debug&lt;/code&gt;命令都没法用。
最后在参考老师给的资料和网上相关资料的基础上，完成了汇编开发环境的搭建，做下记录，以备后用。&lt;/p&gt;
&lt;p&gt;整个开发环境的搭建主要有以下几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dos模拟器DosBox的安装和本地文件夹的挂载&lt;/li&gt;
&lt;li&gt;masm、link、debug等工具的安装&lt;/li&gt;
&lt;li&gt;环境变量的配置&lt;/li&gt;
&lt;li&gt;自动运行脚本的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上是基本步骤。文中所用到的各个软件可以在&lt;a class=&#34;link&#34; href=&#34;http://qn-cdn.zacharyjia.me/file%e6%b1%87%e7%bc%96%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba.zip&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;这里&lt;/a&gt;下载&lt;/p&gt;
&lt;p&gt;下面开始正式的安装和搭建过程。&lt;/p&gt;
&lt;h3 id=&#34;0x0-dos模拟器dosbox的安装和本地文件夹的挂载&#34;&gt;0x0. Dos模拟器DosBox的安装和本地文件夹的挂载&lt;/h3&gt;
&lt;p&gt;从上面的压缩包中找到DosBox的安装文件，安装即可。安装完成后可以桌面或者开始菜单的图标打开DosBox.如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgDosBox.png&#34; alt=&#34;DosBox&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;可以看到它默认的系统盘是Z盘。
下面我们可以通过以下命令将本地电脑的一个文件夹挂载到DosBox中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount c e:\masm611
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条命令的含义就是将本地的&lt;code&gt;e:\masm611&lt;/code&gt;这个文件夹挂载到DosBox中的C盘里。
也就是说你在DosBox中访问C盘的资源就可以看到这个文件夹中的内容了。
可以通过&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c: 
dir
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两条命令查看到其中的内容。&lt;/p&gt;
&lt;h3 id=&#34;0x1-masmlinkdebug等工具的安装&#34;&gt;0x1. masm、link、debug等工具的安装&lt;/h3&gt;
&lt;p&gt;我们在进行汇编编程的过程中，上面说的这几个工具都是非常常用的。Masm是编译器，link是链接器，debug是用来调试程序的。&lt;/p&gt;
&lt;p&gt;首先我们来安装masm，这里我使用的是Masm6.11的安装版，我没有尝试过只使用一个masm.exe文件是否能够成功，可以自行尝试。
把压缩包中的Masm611.zip中的几个文件夹解压到刚才挂载的文件夹中（e:\masm611），然后从DosBox中进入DISK1文件夹，运行其中的setup.exe:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd DISK1 回车
setup 回车
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时你就可以看到上古时代的软件安装界面了^_^&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%85.png&#34; alt=&#34;安装&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;按照提示首先按回车继续，然后选择&lt;code&gt;Install the Macro Assembler using defaults&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%852.png&#34; alt=&#34;安装2&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;然后选择安装位置，我们选择刚刚挂载的C盘。&lt;/p&gt;
&lt;p&gt;然后确认我们的选择。我们选择&lt;code&gt;NO CHANGES&lt;/code&gt;继续安装即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/img%e5%ae%89%e8%a3%853.png&#34; alt=&#34;安装3&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;最后等待一会儿之后就可以安装完成了。（确实要等&lt;em&gt;一会儿&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;回到命令输入界面后，我们可以通过cd命令进入到&lt;code&gt;c:\masm611\bin&lt;/code&gt;这个目录，然后通过dir命令查看所有文件，如果你能找到
&lt;code&gt;masm.exe&lt;/code&gt;这个文件，那么你这一步你就成功了。&lt;/p&gt;
&lt;p&gt;接着我们安装link和debug工具。其实不算安装，只要在windows中将压缩包里的两个exe文件复制到&lt;code&gt;E:\masm611\masm611\bin&lt;/code&gt;这个文件夹里就可以了。
然后在DosBox里再次查看&lt;code&gt;c:\masm611\bin&lt;/code&gt;这个目录，能看到刚复制进去的两个文件就OK了。如果看不到的话，就执行下面这条命令再查看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rescan
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这条命令是用来清除磁盘缓存的。&lt;/p&gt;
&lt;p&gt;最后，你的文件夹里应该是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgbin.png&#34; alt=&#34;bin&#34;  /&gt;&lt;/p&gt;
&lt;h3 id=&#34;0x2-环境变量的配置&#34;&gt;0x2. 环境变量的配置&lt;/h3&gt;
&lt;p&gt;我们现在已经可以使用使用masm、Link、debug这些命令进行汇编的编程了，但是每次都要输入全路径很麻烦，所以要通过配置环境变量来简化我们的操作。
相信学习过java开发的人都了解环境变量的作用了。在dos下设置环境变量只需要一条命令就行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set PATH=%PATH%;c:\masm611\bin\;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是在原来的PATH的基础上，再加入c:\masm611\bin这个路径，也就是我们的masm等文件所在的路径。
执行完上面的命令之后，你应该就可以直接在里面输入:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;masm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来运行masm程序了。like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgmasm.png&#34; alt=&#34;masm&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;这样这一步也成功完成了。&lt;/p&gt;
&lt;h3 id=&#34;0x3-自动运行脚本的配置&#34;&gt;0x3. 自动运行脚本的配置&lt;/h3&gt;
&lt;p&gt;到这里，其实你已经可以愉快的开发了。然而当你下次再打开DosBox的时候，你会发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;WTF？C盘怎么不见了！？&amp;quot;
&amp;quot;我的masm命令怎么运行不了了？！&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是因为你刚才做的配置都不能保存，关闭DosBox之后就都没了~_~
为了解决这个问题，我们可以对DosBox进行配置，让它在每次启动的时候自动为我们执行上面的操作。&lt;/p&gt;
&lt;p&gt;在打开DosBox的时候，你应该会看到除了DosBox的窗口之外，还启动了另一个命令行窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qn-cdn.zacharyjia.me/imgconfig.png&#34; alt=&#34;config&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;然后我画红线的位置就是配置文件所在的地方，使用文本(ji)编(shi)辑(ben)器打开这个文件，然后找到最后的[autoexec]部分，在后面追加以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mount c e:\masm611
set PATH=%PATH%;c:\masm611\bin\;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别忘记保存。这时，你再重新打开DosBox试试，发现启动完成之后，它已经自动执行了这两条命令了。这时就可以直接使用masm等命令了！&lt;/p&gt;
&lt;h3 id=&#34;0x4-备注&#34;&gt;0x4. 备注&lt;/h3&gt;
&lt;p&gt;我的安装过程中并没有在DosBox安装文本编辑器来编辑代码，因为我不想在Dos的命令行中写代码。
代码可以直接在e:\masm611这个文件夹中写，然后进DosBox编译链接调试就行，我相信大家还是更爱windows下的文本编辑器吧。&lt;/p&gt;
&lt;p&gt;当然如果你非要在Dos下编辑文件的话，可以去网上找一个Dos下的edit.exe复制到DosBox里面使用。&lt;/p&gt;</description>
        </item>
        
    </channel>
</rss>
